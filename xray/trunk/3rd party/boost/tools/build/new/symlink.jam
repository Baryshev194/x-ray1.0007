#  Copyright (C) 2002-2003, Rene Rivera. Permission to copy, use, modify, sell and
#  distribute this software is granted provided this copyright notice appears in
#  all copies. This software is provided "as is" without express or implied
#  warranty, and with no claim as to its suitability for any purpose.

# Defines the "symlink" special target. 'symlink' targets make symbolic links
# to the sources.

import numbers ;
import targets ;
import virtual-target ;
import class ;
import property ;
import modules ;
import os ;
import feature ;

count = 0 ;

feature.feature symlink-location : project-relative build-relative : incidental ;

# The class representing "symlink" targets.
#
rule symlink-targets (
    project
    : targets *
    : sources *
    )
{
    # Generate a fake name for now. Need unnamed targets eventually.
    local c = [ modules.peek symlink : count ] ;
    modules.poke symlink : count : [ numbers.increment $(c) ] ;
    local fake-name = symlink#$(c) ;
    
    basic-target.__init__ $(fake-name) : $(project) : $(sources) ;
    
    # Remember the targets to map the sources onto. Pad or truncate
    # to fit the sources given.
    self.targets = ;
    for local source in $(sources)
    {
        if $(targets)
        {
            self.targets += $(targets[1]) ;
            targets = $(targets[2-]) ;
        }
        else
        {
            self.targets += $(source) ;
        }
    }
    
    # The virtual targets corresponding to the given targets.
    self.virtual-targets = ;
    
    rule construct ( source-targets * : property-set )
    {
        local i = 1 ;
        for local t in $(source-targets)
        {
            local s = $(self.targets[$(i)]) ;
            local vt = [ class.new file-target $(s:D=) : [ $(t).type ] : $(self.project) ] ;
            $(vt).action [ class.new action $(vt) : $(t) : symlink.ln : $(property-set) ] ;
            
            # Place the symlink in the directory relative to the project
            # location, instead of placing it in the build directory.
            if [ property.select <symlink-location> : [ $(property-set).raw ] ] = <symlink-location>project-relative
            {
                $(vt).set-path [ project.path-relative-to-project-location 
                    $(s:D) $(self.project) ] ;
            }
            
            self.virtual-targets += $(vt) ;
            i = [ numbers.increment $(i) ] ;
        }
        return $(self.virtual-targets) ;
    }
}
class.class symlink-targets : basic-target ;

# Creates a symbolic link from a set of targets to a set of sources.
# The targets and sources map one to one. The symlinks generated are
# limited to be the ones given as the sources. That is, the targets
# are either padded or trimmed to equate to the sources. The padding
# is done with the name of the corresponding source. For example::
#
#     symlink : one two ;
#
# Is equal to::
#
#     symlink one two : one two ;
#
# Names for symlink are relative to the project location. They cannot
# include ".." path components.
rule symlink (
    targets *
    : sources *
    )
{
    local project = [ CALLER_MODULE ] ;
    
    return [ targets.main-target-alternative
        [ class.new symlink-targets $(project) : $(targets) : $(sources) ] ] ;
}

rule ln
{
    local os ;
    if [ modules.peek : UNIX ] { os = UNIX ; }
    else { os ?= [ os.name ] ; }
    # Remember the path to make the link relative to where the symlink is located.
    local path-to-source = [ path.relative-to
        [ path.make [ on $(<) return $(LOCATE) ] ]
        [ path.make [ on $(>) return $(LOCATE) ] ] ] ;
    if $(path-to-source) = .
    {
        PATH_TO_SOURCE on $(<) = "" ;
    }
    else
    {
        PATH_TO_SOURCE on $(<) = [ path.native $(path-to-source) ] ;
    }
    ln-$(os) $(<) : $(>) ;
}

actions ln-UNIX
{
    ln -f -s '$(>:D=:R=$(PATH_TO_SOURCE))' '$(<)'
}

# there is a way to do this; it's a dummy rule for now
actions ln-NT
{
    echo "NT symlinks not supported yet"
}

IMPORT $(__name__) : symlink : : symlink ;
