<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="Template"
content="C:\PROGRAM FILES\MICROSOFT OFFICE\OFFICE\html.dot">
<meta name="GENERATOR" content="Microsoft FrontPage Express 2.0">
<title>Header </title>
<boost/compressed_pair.hpp>
</head>

<body bgcolor="#FFFFFF" text="#000000" link="#0000FF"
vlink="#800080">

<h2><img src="../../c++boost.gif" width="276" height="86">Header
&lt;<a href="../../boost/detail/compressed_pair.hpp">boost/compressed_pair.hpp</a>&gt;</h2>

<p>All of the contents of &lt;boost/compressed_pair.hpp&gt; are
defined inside namespace boost.</p>

<p>The class compressed pair is very similar to std::pair, but if
either of the template arguments are empty classes, then the
&quot;empty base-class optimisation&quot; is applied to compress
the size of the pair.</p>

<pre>template &lt;class T1, class T2&gt;
class compressed_pair
{
public:
	typedef T1                                                 first_type;
	typedef T2                                                 second_type;
	typedef typename call_traits&lt;first_type&gt;::param_type       first_param_type;
	typedef typename call_traits&lt;second_type&gt;::param_type      second_param_type;
	typedef typename call_traits&lt;first_type&gt;::reference        first_reference;
	typedef typename call_traits&lt;second_type&gt;::reference       second_reference;
	typedef typename call_traits&lt;first_type&gt;::const_reference  first_const_reference;
	typedef typename call_traits&lt;second_type&gt;::const_reference second_const_reference;

	         compressed_pair() : base() {}
	         compressed_pair(first_param_type x, second_param_type y);
	explicit compressed_pair(first_param_type x);
	explicit compressed_pair(second_param_type y);

	compressed_pair&amp; operator=(const compressed_pair&amp;);

	first_reference       first();
	first_const_reference first() const;

	second_reference       second();
	second_const_reference second() const;

	void swap(compressed_pair&amp; y);
};</pre>

<p>The two members of the pair can be accessed using the member
functions first() and second(). Note that not all member
functions can be instantiated for all template parameter types.
In particular compressed_pair can be instantiated for reference
and array types, however in these cases the range of constructors
that can be used are limited. If types T1 and T2 are the same
type, then there is only one version of the single-argument
constructor, and this constructor initialises both values in the
pair to the passed value.</p>

<p>Note that compressed_pair can not be instantiated if either of
the template arguments is a union type, unless there is compiler
support for boost::is_union, or if boost::is_union is specialised
for the union type.</p>

<p>Finally, a word of caution for Visual C++ 6 users: if either
argument is an empty type, then assigning to that member will
produce memory corruption, unless the empty type has a &quot;do
nothing&quot; assignment operator defined. This is due to a bug
in the way VC6 generates implicit assignment operators.</p>

<hr>

<p>Revised 08 May 2001</p>

<p>© Copyright boost.org 2000. Permission to copy, use, modify,
sell and distribute this document is granted provided this
copyright notice appears in all copies. This document is provided
&quot;as is&quot; without express or implied warranty, and with
no claim as to its suitability for any purpose.</p>

<p>Based on contributions by Steve Cleary, Beman Dawes, Howard
Hinnant and John Maddock.</p>

<p>Maintained by <a href="mailto:John_Maddock@compuserve.com">John
Maddock</a>, the latest version of this file can be found at <a
href="http://www.boost.org">www.boost.org</a>, and the boost
discussion list at <a
href="http://www.yahoogroups.com/list/boost">www.yahoogroups.com/list/boost</a>.</p>

<p>&nbsp;</p>
</body>
</html>
