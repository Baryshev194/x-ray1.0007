/*=============================================================================
    Lexer

    Spirit V1.2
    Copyright (c) 2001, Daniel C. Nuffer

    This software is provided 'as-is', without any express or implied
    warranty. In no event will the copyright holder be held liable for
    any damages arising from the use of this software.

    Permission is granted to anyone to use this software for any purpose,
    including commercial applications, and to alter it and redistribute
    it freely, subject to the following restrictions:

    1.  The origin of this software must not be misrepresented; you must
        not claim that you wrote the original software. If you use this
        software in a product, an acknowledgment in the product documentation
        would be appreciated but is not required.

    2.  Altered source versions must be plainly marked as such, and must
        not be misrepresented as being the original software.

    3.  This notice may not be removed or altered from any source
        distribution.

    Acknowledgements:

        Special thanks to Dan Nuffer, John (EBo) David, Chris Uzdavinis,
        and Doug Gregor. These people are most instrumental in steering
        Spirit in the right direction.

        Special thanks also to people who have contributed to the code base
        and sample code, ported Spirit to various platforms and compilers,
        gave suggestions, reported and provided bug fixes. Alexander
        Hirner, Andy Elvey, Bogdan Kushnir, Brett Calcott, Bruce Florman,
        Changzhe Han, Colin McPhail, Hakki Dogusan, Jan Bares, Joseph
        Smith, Martijn W. van der Lee, Raghavendra Satish, Remi Delcos, Tom
        Spilman, Vladimir Prus, W. Scott Dillman, David A. Greene, Bob
        Bailey, Hartmut Kaiser.

        Finally special thanks also to people who gave feedback and
        valuable comments, particularly members of Spirit's Source Forge
        mailing list and boost.org.

    URL: http://spirit.sourceforge.net/


    TODO List:
        create regression test suite.
        complete existing regex functionality.
        refactor createdfa() and make_ccl class.
        callback objects (called when a match is made.)
        lexer states.
        beginning/ending contexts.
        ^ and $
        DFA minimization.
        DFA table compression.
        DFA serialization to save recomputing the DFA.

=============================================================================*/
#ifndef BOOST_SPIRIT_LEXER_HPP
#define BOOST_SPIRIT_LEXER_HPP

///////////////////////////////////////////////////////////////////////////////
#include <set>
#include <map>
#include <stack>
#include <utility> // for pair
#ifdef BOOST_SPIRIT_DEBUG
#include <iostream>
#endif

///////////////////////////////////////////////////////////////////////////////
namespace spirit
{

typedef unsigned char uchar;
typedef unsigned int node_id_t;
static node_id_t invalid_node = node_id_t(-1);
typedef std::set<node_id_t> node_set;
typedef std::vector<uchar> uchar_vector;
typedef std::map<node_id_t, node_set> followpos_t;
typedef std::vector<uchar_vector> state_match_t;
typedef std::pair<std::vector<std::vector<node_id_t> >, 
                  std::vector<node_id_t> > dfa_t;

class bad_regex : public std::exception
{
};

namespace lexerimpl
{

class node
{
public:

    virtual ~node() {}

    virtual node* clone() const = 0;
    virtual bool nullable() const = 0;
    virtual node_set firstpos() const = 0;
    virtual node_set lastpos() const = 0;
    virtual void compute_followpos(followpos_t& followpos) const = 0;
    virtual void compute_state_match(state_match_t& state_match) const = 0;
    virtual void get_eof_ids(node_set& eof_set) const = 0;
#ifdef BOOST_SPIRIT_DEBUG
    virtual void dump(std::ostream& out) const = 0;
#endif

    static node_id_t leaf_count;
};

class char_node : public node
{

public:

	char_node(const uchar c);
    char_node(const char_node& x);
    virtual ~char_node(){}

    virtual node* clone() const;
    virtual bool nullable() const;
    virtual node_set firstpos() const;
    virtual node_set lastpos() const;
    virtual void compute_followpos(followpos_t& followpos) const;
    virtual void compute_state_match(state_match_t& state_match ) const;
    virtual void get_eof_ids(node_set& eof_set) const;
#ifdef BOOST_SPIRIT_DEBUG
    virtual void dump(std::ostream& out) const;
#endif

private:

	uchar m_char;
    node_id_t m_node_num;
};

char_node::char_node(const uchar c)
    : node()
    , m_char(c)
    , m_node_num(node::leaf_count++)
{
}

char_node::char_node(const char_node& x)
    : node(x)
    , m_char(x.m_char)
    , m_node_num(node::leaf_count++)
{
}

node * 
char_node::clone() const
{
    return new char_node(*this);
}

bool 
char_node::nullable() const
{
    return false;
}

node_set 
char_node::firstpos() const
{
    node_set rval;
    rval.insert(m_node_num);
    return rval;
}

node_set 
char_node::lastpos() const
{
    return firstpos();
}

void 
char_node::compute_followpos(followpos_t&) const
{
    return;
}

void
char_node::compute_state_match(state_match_t& state_match) const
{
    if (state_match.size() < m_node_num + 1)
        state_match.resize(m_node_num + 1);
    state_match[m_node_num].resize(256);
    state_match[m_node_num][m_char] = 1;
}

void 
char_node::get_eof_ids(node_set&) const
{
    return;
}

#ifdef BOOST_SPIRIT_DEBUG
void 
char_node::dump(std::ostream& out) const
{
    out << "\nchar_node m_char = " << m_char;
    out << " m_node_num = " << m_node_num;
    out << " nullable() = " << (nullable() ? "true" : "false");
    out << " firstpos() = ";
    node_set fp = firstpos();
    std::copy(fp.begin(), fp.end(), 
            std::ostream_iterator<node_id_t>(out, ","));

    out << " lastpos() = ";
    node_set lp = lastpos();
    std::copy(lp.begin(), lp.end(), 
            std::ostream_iterator<node_id_t>(out, ","));
}
#endif


class epsilon_node : public node
{

public:

	epsilon_node();
    epsilon_node(const epsilon_node& x);
    virtual ~epsilon_node(){}

    virtual node* clone() const;
    virtual bool nullable() const;
    virtual node_set firstpos() const;
    virtual node_set lastpos() const;
    virtual void compute_followpos(followpos_t& followpos) const;
    virtual void compute_state_match(state_match_t& state_match ) const;
    virtual void get_eof_ids(node_set& eof_set) const;
#ifdef BOOST_SPIRIT_DEBUG
    virtual void dump(std::ostream& out) const;
#endif

private:

    node_id_t m_node_num;
};

inline
epsilon_node::epsilon_node()
    : node()
    , m_node_num(node::leaf_count++)
{
}

epsilon_node::epsilon_node(const epsilon_node& x)
    : node(x)
    , m_node_num(node::leaf_count++)
{
}

node * 
epsilon_node::clone() const
{
    return new epsilon_node(*this);
}

bool 
epsilon_node::nullable() const
{
    return true;
}

node_set 
epsilon_node::firstpos() const
{
    return node_set();
}

node_set 
epsilon_node::lastpos() const
{
    return node_set();
}

void 
epsilon_node::compute_followpos(followpos_t&) const
{
    return;
}

void
epsilon_node::compute_state_match(state_match_t& state_match) const
{
    if (state_match.size() < m_node_num + 1)
        state_match.resize(m_node_num + 1);
    state_match[m_node_num].resize(256, 1);
}

void 
epsilon_node::get_eof_ids(node_set&) const
{
    return;
}

#ifdef BOOST_SPIRIT_DEBUG
void 
epsilon_node::dump(std::ostream& out) const
{
    out << "\nepsilon_node";
    out << " m_node_num = " << m_node_num;
    out << " nullable() = " << (nullable() ? "true" : "false");
    out << " firstpos() = ";
    node_set fp = firstpos();
    std::copy(fp.begin(), fp.end(), 
            std::ostream_iterator<node_id_t>(out, ","));

    out << " lastpos() = ";
    node_set lp = lastpos();
    std::copy(lp.begin(), lp.end(), 
            std::ostream_iterator<node_id_t>(out, ","));
}
#endif


class or_node : public node
{

public:

	or_node(const node * left, const node * right);
    or_node(const or_node& x);
    virtual ~or_node(){}

    virtual node* clone() const;
    virtual bool nullable() const;
    virtual node_set firstpos() const;
    virtual node_set lastpos() const;
    virtual void compute_followpos(followpos_t& followpos) const;
    virtual void compute_state_match(state_match_t& state_match ) const;
    virtual void get_eof_ids(node_set& eof_set) const;
#ifdef BOOST_SPIRIT_DEBUG
    virtual void dump(std::ostream& out) const;
#endif

private:

    std::auto_ptr<const node > m_left;
    std::auto_ptr<const node > m_right;	
};

inline
or_node::or_node(const node * left, const node * right)
    : node()
    , m_left(left)
    , m_right(right)
{
}

or_node::or_node(const or_node& x)
    : node(x)
    , m_left(x.m_left->clone())
    , m_right(x.m_right->clone())
{
}

node * 
or_node::clone() const
{
    return new or_node(*this);
}

bool 
or_node::nullable() const
{
    return m_left->nullable() || m_right->nullable();
}

node_set 
or_node::firstpos() const
{
    node_set rval;
    node_set l = m_left->firstpos();
    node_set r = m_right->firstpos();
    std::set_union(l.begin(), l.end(), r.begin(), r.end(),
            std::inserter(rval, rval.begin()));
    return rval;
}

node_set 
or_node::lastpos() const
{
    node_set rval;
    node_set l = m_left->lastpos();
    node_set r = m_right->lastpos();
    std::set_union(l.begin(), l.end(), r.begin(), r.end(),
            std::inserter(rval, rval.begin()));
    return rval;
}

void 
or_node::compute_followpos(followpos_t& followpos) const
{
    m_left->compute_followpos(followpos);
    m_right->compute_followpos(followpos);
}

void
or_node::compute_state_match(state_match_t& state_match) const
{
    m_left->compute_state_match(state_match);
    m_right->compute_state_match(state_match);
}

void 
or_node::get_eof_ids(node_set& eof_nodes) const
{
    m_left->get_eof_ids(eof_nodes);
    m_right->get_eof_ids(eof_nodes);
}

#ifdef BOOST_SPIRIT_DEBUG
void 
or_node::dump(std::ostream& out) const
{
    out << "\nor_node";
    out << " nullable() = " << (nullable() ? "true" : "false");
    out << " firstpos() = ";
    node_set fp = firstpos();
    std::copy(fp.begin(), fp.end(), 
            std::ostream_iterator<node_id_t>(out, ","));

    out << " lastpos() = ";
    node_set lp = lastpos();
    std::copy(lp.begin(), lp.end(), 
            std::ostream_iterator<node_id_t>(out, ","));

    m_left->dump(out);
    m_right->dump(out);
}
#endif


class cat_node : public node
{

public:

	cat_node(const node * left, const node * right);
    cat_node(const cat_node& x);
    virtual ~cat_node(){}

    virtual node* clone() const;
    virtual bool nullable() const;
    virtual node_set firstpos() const;
    virtual node_set lastpos() const;
    virtual void compute_followpos(followpos_t& followpos) const;
    virtual void compute_state_match(state_match_t& state_match ) const;
    virtual void get_eof_ids(node_set& eof_set) const;
#ifdef BOOST_SPIRIT_DEBUG
    virtual void dump(std::ostream& out) const;
#endif

private:

    std::auto_ptr<const node > m_left;
    std::auto_ptr<const node > m_right;	
};

inline
cat_node::cat_node(const node * left, const node * right)
    : node()
    , m_left(left)
    , m_right(right)
{
}

cat_node::cat_node(const cat_node& x)
    : node(x)
    , m_left(x.m_left->clone())
    , m_right(x.m_right->clone())
{
}

node * 
cat_node::clone() const
{
    return new cat_node(*this);
}

bool 
cat_node::nullable() const
{
    return m_left->nullable() && m_right->nullable();
}

node_set 
cat_node::firstpos() const
{
    if (m_left->nullable())
    {
        node_set rval;
        node_set l = m_left->firstpos();
        node_set r = m_right->firstpos();
        std::set_union(l.begin(), l.end(), r.begin(), r.end(),
                std::inserter(rval, rval.begin()));
        return rval;
    }
    else
    {
        return m_left->firstpos();
    }
}

node_set 
cat_node::lastpos() const
{
    if (m_right->nullable())
    {
        node_set rval;
        node_set l = m_left->lastpos();
        node_set r = m_right->lastpos();
        std::set_union(l.begin(), l.end(), r.begin(), r.end(),
                std::inserter(rval, rval.begin()));
        return rval;
    }
    else
    {
        return m_right->lastpos();
    }
}

void 
cat_node::compute_followpos(followpos_t& followpos) const
{
    node_set l = m_left->lastpos();
    for (node_set::iterator i = l.begin();
            i != l.end();
            ++i)
    {
        node_set rf = m_right->firstpos();
        followpos[*i].insert(rf.begin(), rf.end());
    }

    m_left->compute_followpos(followpos);
    m_right->compute_followpos(followpos);
}

void
cat_node::compute_state_match(state_match_t& state_match) const
{
    m_left->compute_state_match(state_match);
    m_right->compute_state_match(state_match);
}

void 
cat_node::get_eof_ids(node_set& eof_nodes) const
{
    m_left->get_eof_ids(eof_nodes);
    m_right->get_eof_ids(eof_nodes);
}

#ifdef BOOST_SPIRIT_DEBUG
void 
cat_node::dump(std::ostream& out) const
{
    out << "\ncat_node";
    out << " nullable() = " << (nullable() ? "true" : "false");
    out << " firstpos() = ";
    node_set fp = firstpos();
    std::copy(fp.begin(), fp.end(), 
            std::ostream_iterator<node_id_t>(out, ","));

    out << " lastpos() = ";
    node_set lp = lastpos();
    std::copy(lp.begin(), lp.end(), 
            std::ostream_iterator<node_id_t>(out, ","));

    m_left->dump(out);
    m_right->dump(out);
}
#endif


class star_node : public node
{

public:

	star_node(const node * left);
    star_node(const star_node& x);
    virtual ~star_node(){}

    virtual node* clone() const;
    virtual bool nullable() const;
    virtual node_set firstpos() const;
    virtual node_set lastpos() const;
    virtual void compute_followpos(followpos_t& followpos) const;
    virtual void compute_state_match(state_match_t& state_match ) const;
    virtual void get_eof_ids(node_set& eof_set) const;
#ifdef BOOST_SPIRIT_DEBUG
    virtual void dump(std::ostream& out) const;
#endif

private:

    std::auto_ptr<const node > m_left;
};

inline
star_node::star_node(const node * left)
    : node()
    , m_left(left)
{
}

inline
star_node::star_node(const star_node& x)
    : node(x)
    , m_left(x.m_left->clone())
{
}

node * 
star_node::clone() const
{
    return new star_node(*this);
}

bool 
star_node::nullable() const
{
    return true;
}

node_set 
star_node::firstpos() const
{
    return m_left->firstpos();
}

node_set 
star_node::lastpos() const
{
    return m_left->lastpos();
}

void 
star_node::compute_followpos(followpos_t& followpos) const
{
    node_set lp = this->lastpos();
    for (node_set::iterator i = lp.begin();
            i != lp.end();
            ++i)
    {
        node_set fp = this->firstpos();
        followpos[*i].insert(fp.begin(), fp.end());
    }

    m_left->compute_followpos(followpos);
}

void
star_node::compute_state_match(state_match_t& state_match) const
{
    m_left->compute_state_match(state_match);
}

void 
star_node::get_eof_ids(node_set& eof_nodes) const
{
    m_left->get_eof_ids(eof_nodes);
}

#ifdef BOOST_SPIRIT_DEBUG
void 
star_node::dump(std::ostream& out) const
{
    out << "\nstar_node";
    out << " nullable() = " << (nullable() ? "true" : "false");
    out << " firstpos() = ";
    node_set fp = firstpos();
    std::copy(fp.begin(), fp.end(), 
            std::ostream_iterator<node_id_t>(out, ","));

    out << " lastpos() = ";
    node_set lp = lastpos();
    std::copy(lp.begin(), lp.end(), 
            std::ostream_iterator<node_id_t>(out, ","));

    m_left->dump(out);
}
#endif


class eof_node : public node
{

public:

	eof_node();
    eof_node(const eof_node& x);
    virtual ~eof_node(){}

    virtual node* clone() const;
    virtual bool nullable() const;
    virtual node_set firstpos() const;
    virtual node_set lastpos() const;
    virtual void compute_followpos(followpos_t& followpos) const;
    virtual void compute_state_match(state_match_t& state_match ) const;
    virtual void get_eof_ids(node_set& eof_set) const;
#ifdef BOOST_SPIRIT_DEBUG
    virtual void dump(std::ostream& out) const;
#endif

private:

    node_id_t m_node_num;
};

inline
eof_node::eof_node()
    : node()
    , m_node_num(node::leaf_count++)
{
}

eof_node::eof_node(const eof_node& x)
    : node(x)
    , m_node_num(node::leaf_count++)
{
}

node * 
eof_node::clone() const
{
    return new eof_node(*this);
}

bool 
eof_node::nullable() const
{
    return false;
}

node_set 
eof_node::firstpos() const
{
    node_set rval;
    rval.insert(m_node_num);
    return rval;
}

node_set 
eof_node::lastpos() const
{
    node_set rval;
    rval.insert(m_node_num);
    return rval;
}

void 
eof_node::compute_followpos(followpos_t&) const
{
    return;
}

void
eof_node::compute_state_match(state_match_t& state_match) const
{
    if (state_match.size() < m_node_num + 1)
        state_match.resize(m_node_num + 1);
    state_match[m_node_num].resize(256, 0);
}

void 
eof_node::get_eof_ids(node_set& eof_nodes) const
{
    eof_nodes.insert(m_node_num);
}

#ifdef BOOST_SPIRIT_DEBUG
void 
eof_node::dump(std::ostream& out) const
{
    out << "\neof_node";
    out << " m_node_num = " << m_node_num;
    out << " nullable() = " << (nullable() ? "true" : "false");
    out << " firstpos() = ";
    node_set fp = firstpos();
    std::copy(fp.begin(), fp.end(), 
            std::ostream_iterator<node_id_t>(out, ","));

    out << " lastpos() = ";
    node_set lp = lastpos();
    std::copy(lp.begin(), lp.end(), 
            std::ostream_iterator<node_id_t>(out, ","));
}
#endif

class ccl_node : public node
{

public:

	ccl_node(const std::vector<uchar>& v);
    ccl_node(const uchar c1, const uchar c2);
    ccl_node(const ccl_node& x);
    virtual ~ccl_node(){}

    virtual node* clone() const;
    virtual bool nullable() const;
    virtual node_set firstpos() const;
    virtual node_set lastpos() const;
    virtual void compute_followpos(followpos_t& followpos) const;
    virtual void compute_state_match(state_match_t& state_match ) const;
    virtual void get_eof_ids(node_set& eof_set) const;
#ifdef BOOST_SPIRIT_DEBUG
    virtual void dump(std::ostream& out) const;
#endif

private:

    std::vector<uchar> m_match;
    node_id_t m_node_num;
};

ccl_node::ccl_node(const std::vector<uchar>& v)
    : node()
    , m_match(v)
    , m_node_num(node::leaf_count++)
{
    m_match.resize(256); // make sure it's the right size
}

ccl_node::ccl_node(const uchar c1, const uchar c2)
    : node()
    , m_match(256, 0)
    , m_node_num(node::leaf_count++)
{
    assert(c1 < c2);
    for (size_t i = c1; i <= c2; ++i)
    {
        m_match[i] = 1;
    }
}

ccl_node::ccl_node(const ccl_node& x)
    : node(x)
    , m_match(x.m_match)
    , m_node_num(node::leaf_count++)
{
}

node * 
ccl_node::clone() const
{
    return new ccl_node(*this);
}

bool 
ccl_node::nullable() const
{
    return false;
}

node_set 
ccl_node::firstpos() const
{
    node_set rval;
    rval.insert(m_node_num);
    return rval;
}

node_set 
ccl_node::lastpos() const
{
    return firstpos();
}

void 
ccl_node::compute_followpos(followpos_t&) const
{
    return;
}

void
ccl_node::compute_state_match(state_match_t& state_match) const
{
    if (state_match.size() < m_node_num + 1)
        state_match.resize(m_node_num + 1);
    state_match[m_node_num] = m_match;
}

void 
ccl_node::get_eof_ids(node_set&) const
{
    return;
}

#ifdef BOOST_SPIRIT_DEBUG
void 
ccl_node::dump(std::ostream& out) const
{
    out << "\nccl_node m_match = ";
    for (size_t i = 0; i < m_match.size(); ++i)
    {
        if (m_match[i])
            out << i << ", ";
    }
    out << " m_node_num = " << m_node_num;
    out << " nullable() = " << (nullable() ? "true" : "false");
    out << " firstpos() = ";
    node_set fp = firstpos();
    std::copy(fp.begin(), fp.end(), 
            std::ostream_iterator<node_id_t>(out, ","));

    out << " lastpos() = ";
    node_set lp = lastpos();
    std::copy(lp.begin(), lp.end(), 
            std::ostream_iterator<node_id_t>(out, ","));
}
#endif


node_id_t node::leaf_count = 0;

template <typename IteratorT>
class make_concat
{
public:

    make_concat(std::stack<node*>& the_stack)
        : m_stack(the_stack)
        {}

    void operator()(const IteratorT&, const IteratorT&) const
    {
        node* right = m_stack.top();
        m_stack.pop();
        node* left = m_stack.top();
        m_stack.pop();
        node* newnode = new cat_node(left, right);
        m_stack.push(newnode);
    }

    std::stack<node*>& m_stack;
};

template <typename CharT>
unsigned char get_byte(CharT c, unsigned int byte)
{
    static unsigned long mask[] =
    {
        0xFF000000,
        0x00FF0000,
        0x0000FF00,
        0x000000FF
    };

    return (c & mask[byte]) >> ((sizeof(c) - 1 - byte) * 8);
}

template <typename IteratorT>
class make_char
{
public:
    typedef typename std::iterator_traits<IteratorT>::value_type char_t;

    make_char(std::stack<node*>& the_stack)
        : m_stack(the_stack)
        {}

    void operator()(IteratorT& first, const IteratorT& last) const
    {
        node* newnode;
        char_t the_char;
        lex_escape_ch_p[ref(the_char)].parse(first, last);
        if (sizeof(*first) == 1)
        {
            newnode = new char_node(the_char);
        }
        else
        {
            newnode = new char_node(get_byte(the_char, 0));
            for (unsigned int i = 1; i < sizeof(the_char); ++i)
            {
                node* cnode = new char_node(get_byte(the_char, i));
                node* top_node = new cat_node(newnode, cnode);
                newnode = top_node;
            }
        }
        m_stack.push(newnode);
    }

    std::stack<node*>& m_stack;
};

template <typename IteratorT>
class make_star
{
public:
    typedef typename std::iterator_traits<IteratorT>::value_type char_t;

    make_star(std::stack<node*>& the_stack)
        : m_stack(the_stack)
        {}

    void operator()(const char_t) const
    {
        node* left = m_stack.top();
        m_stack.pop();
        node* newnode = new star_node(left);
        m_stack.push(newnode);
    }

    std::stack<node*>& m_stack;
};

template <typename IteratorT>
class make_or
{
public:

    make_or(std::stack<node*>& the_stack)
        : m_stack(the_stack)
        {}

    void operator()(const IteratorT&, const IteratorT&) const
    {
        node* right = m_stack.top();
        m_stack.pop();
        node* left = m_stack.top();
        m_stack.pop();
        node* newnode = new or_node(left, right);
        m_stack.push(newnode);
    }

    std::stack<node*>& m_stack;
};

template <typename IteratorT>
class make_plus
{
public:
    typedef typename std::iterator_traits<IteratorT>::value_type char_t;

    make_plus(std::stack<node*>& the_stack)
        : m_stack(the_stack)
        {}

    void operator()(const char_t) const
    {
        node* left = m_stack.top();
        m_stack.pop();

        node* copy = left->clone();

        node* new_star = new star_node(copy);
        node* new_cat = new cat_node(left, new_star);
        m_stack.push(new_cat);
    }

    std::stack<node*>& m_stack;
};

template <typename IteratorT>
class make_optional
{
public:
    typedef typename std::iterator_traits<IteratorT>::value_type char_t;

    make_optional(std::stack<node*>& the_stack)
        : m_stack(the_stack)
        {}

    void operator()(const char_t) const
    {
        node* left = m_stack.top();
        m_stack.pop();

        node* new_or = new or_node(left, new epsilon_node());
        m_stack.push(new_or);
    }

    std::stack<node*>& m_stack;
};

namespace ccl_utils
{
    template <typename char_t>
    impl::range_run<char_t> negate_range_run(
            const impl::range_run<char_t>& rr)
    {
        impl::range_run<char_t> newrr;
        newrr.set(impl::full_range<char_t>());
        for (impl::range_run<char_t>::const_iterator iter = rr.begin(); 
                iter != rr.end(); ++iter)
            newrr.clear(*iter);
        return newrr;
    }

    template <typename char_t>
    void create_nodes(const impl::range_run<char_t>& rr, 
            std::stack<node*>& stack) 
    {

        if (sizeof(char_t) == 1)
        {
            std::vector<uchar> ccl;
            ccl.resize(256);
            for (impl::range_run<char_t>::const_iterator iter = rr.begin(); 
                    iter != rr.end(); ++iter)
            {
                for (int i = iter->first; i <= iter->last; ++i)
                {
                    assert(uchar(i) < 256 && ccl.size() == 256);
                    ccl[uchar(i)] = 1;
                }
            }

            node* new_ccl = new ccl_node(ccl);
            stack.push(new_ccl);
        }
        else
        {
            bool mb_first_time = true;
            for (impl::range_run<char_t>::const_iterator iter = rr.begin(); 
                    iter != rr.end(); ++iter)
            {
                if (iter->first == iter->last)
                {
                    handle_mb_char(iter->first, mb_first_time, stack);
                }
                else
                {
                    handle_mb_range(iter->first, iter->last, mb_first_time, stack);
                }
                mb_first_time = false;
            }
        }
    }

    template <typename char_t>
    void handle_mb_char(char_t c, bool first_time,
            std::stack<node*>& stack)
    {
        node* newnode = create_mb_node_seq(c);

        if (first_time)
        {
            stack.push(newnode);
        }
        else
        {
            node* top = stack.top();
            stack.pop();

            node* newtop = new or_node(top, newnode);
            stack.push(newtop);
        }
    }

    template <typename char_t>
    node* create_mb_node_seq(char_t c)
    {
        node* newnode = new char_node(get_byte(c, 0));
        for (unsigned int i = 1; i < sizeof(c); ++i)
        {
            node* cnode = new char_node(get_byte(c, i));
            node* top_node = new cat_node(newnode, cnode);
            newnode = top_node;
        }
        return newnode;
    }

    template <typename char_t>
    size_t compute_differing_byte(char_t c1, char_t c2)
    {
        size_t rval = 0;
        while (rval < sizeof(c1) && get_byte(c1, rval) == get_byte(c2, rval))
           ++rval;

        return rval; 
    }

    template <typename char_t>
    void handle_mb_range(char_t c1, char_t c2, bool first_time,
            std::stack<node*>& stack)
    {
        // The algorithm can't handle negative value chars, which don't make
        // much sense anyway.
        if (c1 < 0)
            c1 = 0;

        assert(c1 < c2);
        node* newnode = 0;
        node* savednode = 0;
        const size_t differing_byte = compute_differing_byte(c1, c2);
        const size_t sizem1 = sizeof(c1) - 1;
        const size_t ndb = sizem1 - differing_byte;
        for (size_t i = differing_byte; i < sizeof(c1); ++i)
        {
            // generate node for the first byte
            if (differing_byte == 0 && i == ndb)
            {
                size_t diff = get_byte(c2, 0) - get_byte(c1, 0);
                if (diff == 1)
                    continue;
                else if (diff == 2)
                    newnode = new char_node(get_byte(c1, 0) + 1);
                else
                    newnode = new ccl_node(get_byte(c1, 0) + 1, 
                            get_byte(c2, 0) - 1);
            }
            else
            {
                newnode = new char_node(get_byte(c1, 0));
            }
            for (size_t j = 1; j < sizeof(c1); ++j)
            {
                node* cnode;
                if (i == sizem1 && j == differing_byte && j != sizem1)
                {
                    size_t diff = get_byte(c2, j) - get_byte(c1, j);
                    if (diff == 1)
                    {
                        delete newnode;
                        goto end_outer_for; // got to skip this entire section
                    }
                    else if (diff == 2)
                        cnode = new char_node(get_byte(c1, j)+1);
                    else 
                        cnode = new ccl_node(get_byte(c1, j)+1, 
                                get_byte(c2, j)-1);
                }

                else if (i == differing_byte && j == sizem1)
                {
                    if (i != sizem1)
                        cnode = new ccl_node(get_byte(c1, j), 0xFF);
                    else
                        cnode = new ccl_node(get_byte(c1, j), get_byte(c2, j));
                }

                else if (i != differing_byte && i != sizem1 && 
                        j == (sizem1 - i + differing_byte))
                    cnode = new ccl_node(get_byte(c1, j)+1, 0xFF);

                else if (i + j - differing_byte > sizem1)
                    cnode = new ccl_node(0, 0xFF);

                else //if (is plain)
                    cnode = new char_node(get_byte(c1, j));


                node* top_node = new cat_node(newnode, cnode);
                newnode = top_node;
            }

            // or together the various parts
            if (savednode)
            {
                node* top_node = new or_node(savednode, newnode);
                savednode = top_node;
            }
            else
            {
                savednode = newnode;
            }
end_outer_for:
            continue;
        }

        // the silly cast is to get rid of a gcc warning, when sizem1 == 0
        // which happens when CharT=char
        for (size_t i = 0; i < ndb; ++i)
        {
            newnode = new char_node(get_byte(c2, 0));
            for (size_t j = 1; j < sizeof(c2); ++j)
            {
                node* cnode;
                if (i == differing_byte && j == sizem1 && i != sizem1)
                    cnode = new ccl_node(0, get_byte(c2, j));

                else if (i != differing_byte && i != sizem1 && 
                        j == (sizem1 - i + differing_byte))
                    cnode = new ccl_node(0, get_byte(c2, j)-1);

                else if (i + j - differing_byte > sizem1)
                    cnode = new ccl_node(0, 0xFF);

                else //if (is plain)
                    cnode = new char_node(get_byte(c2, j));


                node* top_node = new cat_node(newnode, cnode);
                newnode = top_node;
            }

            // or together the various parts
            if (savednode)
            {
                node* top_node = new or_node(savednode, newnode);
                savednode = top_node;
            }
            else
            {
                savednode = newnode;
            }
        }

        
        if (first_time)
        {
            stack.push(savednode);
        }
        else
        {
            node* top = stack.top();
            stack.pop();

            node* newtop = new or_node(top, savednode);
            stack.push(newtop);
        }
    }
} // namespace ccl_utils


template <typename IteratorT>
class make_ccl
{
public:
    typedef typename std::iterator_traits<IteratorT>::value_type char_t;

    make_ccl(std::stack<node*>& the_stack)
        : m_stack(the_stack)
        {}

    void operator()(const IteratorT& first_, const IteratorT& last) const
    {
        IteratorT first = first_;

        assert(*first == '[');

        ++first; // skip over '['
        bool negated_ccl = false;
        if (*first == '^')
        {
            negated_ccl = true;
            ++first;
        }

        impl::range_run<char_t> rr;
        while (first != last && *first != ']')
        {
            if (*first == '[') // it's a ccl_expr like [:space:]
            {
                // TODO: write this
            }
            else
            {
                char_t c1;
                lex_escape_ch_p[ref(c1)].parse(first, last);
                if (*first == '-') // insert a range
                {
                    ++first;
                    char_t c2;
                    lex_escape_ch_p[ref(c2)].parse(first, last);
                    assert(c1 < c2); // Throw exception?
                    rr.set(impl::range<char_t>(c1, c2));
                }
                else // insert 1 char
                {
                    rr.set(impl::range<char_t>(c1, c1));
                }
            }
        }

        if (negated_ccl)
        {
            rr = ccl_utils::negate_range_run(rr);
        }

        ccl_utils::create_nodes(rr, m_stack);
    }

    std::stack<node*>& m_stack;
};

template <typename IteratorT>
class make_any_char
{
public:
    typedef typename std::iterator_traits<IteratorT>::value_type char_t;
    std::stack<node*>& m_stack;

    make_any_char(std::stack<node*>& the_stack)
        : m_stack(the_stack)
        {}

    void operator()(const char_t c) const
    {
        assert(c == '.');
        do_any_char();
    }

    void do_any_char() const
    {
        static impl::range_run<char_t> rr;
        rr.set(impl::full_range<char_t>());
        char_t newline = '\n';
        rr.clear(impl::range<char_t>(newline, newline));

        ccl_utils::create_nodes(rr, m_stack);

    }

};


template <typename IteratorT>
class grammar
{
public:

	typedef rule<IteratorT> rule_t;
    typedef typename std::iterator_traits<IteratorT>::value_type char_t;


	rule_t regex, re, series, singleton, singleton2, fullccl, ccl, string, 
        escseq, ccl_char;
	symbols<> ccl_expr;

    std::stack<node*> node_stack;

	grammar()
	{
		regex = 
            re >> !('/' >> re) >> !ch_p('$');

		re =
			  series >> *(('|' >> series)[make_or<IteratorT>(node_stack)]);

		series =
			  singleton >> *(singleton[make_concat<IteratorT>(node_stack)] );

		singleton = 
			  ch_p('.')[make_any_char<IteratorT>(node_stack)] >> singleton2
			| fullccl >> singleton2
            // TODO: Write a string node generator
			| '"' >> string >> '"' >> singleton2
			| '(' >> re >> ')' >> singleton2
			| ((anychar - chset<>("/|*+?.(){}\\")) | escseq)
                [make_char<IteratorT>(node_stack)] 
              >> singleton2;

		singleton2 =
			  ch_p('*')[make_star<IteratorT>(node_stack)] >> singleton2
			| ch_p('+')[make_plus<IteratorT>(node_stack)] >> singleton2
			| ch_p('?')[make_optional<IteratorT>(node_stack)] >> singleton2
            // TODO: Write a specified repetition generator
			| '"' >> string >> '"' >> singleton2
			| '{' >> uint_p >> '}' >> singleton2
			| '{' >> uint_p >> ',' >> '}' >> singleton2
			| '{' >> uint_p >> ',' >> uint_p >> '}' >> singleton2
			| epsilon;

		fullccl =
			('[' >> !ch_p('^') >> ccl >> ']')[make_ccl<IteratorT>(node_stack)];

		ccl =
            *(ccl_expr | (ccl_char >> !('-' >> ccl_char)));

		ccl_char =
			((anychar - chset<>("\\\n]")) | escseq);

		ccl_expr =
			"[:alnum:]",
			"[:alpha:]",
			"[:blank:]",
			"[:cntrl:]",
			"[:digit:]",
			"[:graph:]",
			"[:lower:]",
			"[:print:]",
			"[:punct:]",
			"[:space:]",
			"[:upper:]",
			"[:xdigit:]";

		string =
			*((anychar - chset<>("\"\\")) | escseq);

		escseq =
			ch_p('\\') >> 
				longest[
				(  (anychar - '\n')
				 | chset<>("0-7").repeat(1,11) 
				 | chset<>("xX") >> xdigit.repeat(1,8)
				)];

	    BOOST_SPIRIT_DEBUG_RULE(regex);
        BOOST_SPIRIT_DEBUG_RULE(re);
        BOOST_SPIRIT_DEBUG_RULE(series);
        BOOST_SPIRIT_DEBUG_RULE(singleton);
        BOOST_SPIRIT_DEBUG_RULE(singleton2);
        BOOST_SPIRIT_DEBUG_RULE(fullccl);
        BOOST_SPIRIT_DEBUG_RULE(ccl);
        BOOST_SPIRIT_DEBUG_RULE(string);
        BOOST_SPIRIT_DEBUG_RULE(escseq);
        BOOST_SPIRIT_DEBUG_RULE(ccl_char);
	}
}; // class grammar

template <typename IteratorT>
node* parse(grammar<IteratorT>& g, IteratorT expr)
{
    parse_info<IteratorT>
        result = boost::spirit::parse(expr, g.regex);

    if (!result.full)
    {
        return 0;
    }

    assert(g.node_stack.size() == 1);
    node* rval = g.node_stack.top();
    g.node_stack.pop();
    node* an_eof_node = new eof_node();
    rval = new cat_node(rval, an_eof_node);
    return rval;
}

bool regex_match(const dfa_t& dfa, const char*& first, const char* last,
        int& regex_index)
{
    node_id_t s = 0;
    node_id_t last_accepting_index = invalid_node;
    const uchar* p = (const uchar*)first;
    const uchar* last_accepting_cpos = (const uchar*)first;
    while ((const char*)p != last)
    {
        s = dfa.first[s][*p];
        if (s == invalid_node)
            break;
        ++p;
        if (dfa.second[s] != invalid_node)
        {
            last_accepting_index = s;
            last_accepting_cpos = p;
        }
    }
    if (last_accepting_index != invalid_node)
    {
        // execute dfa.second[last_accepting_state]
#ifdef BOOST_SPIRIT_DEBUG
        std::cout << "dfa.second[" << last_accepting_index << "] = " << 
            dfa.second[last_accepting_index] << '\n';
#endif
        first = (const char*)last_accepting_cpos;
        regex_index = dfa.second[last_accepting_index];
        return true;
    }
    else
        return false;
}

bool regex_match(const dfa_t& dfa, const wchar_t*& first, const wchar_t* last,
        int& regex_index)
{
    node_id_t s = 0;
    node_id_t last_accepting_index = invalid_node;
    const wchar_t* wp = first;
    const wchar_t* last_accepting_cpos = first;
    while ((const wchar_t*)wp != last)
    {
        for (unsigned int i = 0; i < sizeof(wchar_t); ++i)
        {
            s = dfa.first[s][get_byte(*wp,i)];
            if (s == invalid_node)
            {
                goto break_while;
            }
        }
        ++wp;
        if (dfa.second[s] != invalid_node)
        {
            last_accepting_index = s;
            last_accepting_cpos = wp;
        }

    }

break_while:
    if (last_accepting_index != invalid_node)
    {
        // execute dfa.second[s]
#ifdef BOOST_SPIRIT_DEBUG
        std::cout << "dfa.second[" << last_accepting_index << "] = " << 
            dfa.second[last_accepting_index] << '\n';
#endif
        first = (const wchar_t*)last_accepting_cpos;
        regex_index = dfa.second[last_accepting_index];
        return true;
    }
    else
        return false;
}

} // namespace lexerimpl

template <typename CharT, typename TokenT = int>
class lexer
{
    public:
        lexer()
            : g()
            , m_compiled_dfa(false)
            {}

        void register_regex(const CharT* regex, TokenT id);

        template <typename IteratorT>
        TokenT next_token(IteratorT& first, IteratorT& last);

        void createdfa();

#ifdef BOOST_SPIRIT_DEBUG
        void dump(std::ostream& out);
#endif

    private:

        lexerimpl::grammar<const CharT*> g;

        mutable bool m_compiled_dfa;
        mutable dfa_t m_dfa;

        typedef std::vector<std::pair<std::basic_string<CharT>, TokenT> > regex_list_t;
        regex_list_t m_regex_list;
};

template <typename CharT, typename TokenT>
void
lexer<CharT, TokenT>::register_regex(const CharT* regex, TokenT id)
{
    m_regex_list.push_back(std::make_pair(regex, id));
}

template <typename CharT, typename TokenT>
template <typename IteratorT>
TokenT
lexer<CharT, TokenT>::next_token(IteratorT& first, IteratorT& last)
{
    if (!m_compiled_dfa)
    {
        createdfa();
    }

    int regex_index;
    if (!lexerimpl::regex_match(m_dfa, first, last, regex_index))
        return -1;
    else
        return m_regex_list[regex_index].second;
}


// Algorithm from Compilers: Principles, Techniques, and Tools p. 141
template <typename CharT, typename TokenT>
void 
lexer<CharT, TokenT>::createdfa()
{
    using std::map;
    using std::set;
    using std::vector;
    using std::find;

    using namespace lexerimpl;
    node::leaf_count = 0;
    // parse the expressions into a tree
    regex_list_t::iterator ri = m_regex_list.begin();
    std::auto_ptr<node> tree(parse(g, (*ri).first.c_str()));
    if (tree.get() == 0)
        throw bad_regex();

    ++ri;
    for ( ;ri != m_regex_list.end(); ++ri)
    {
        std::auto_ptr<node> next_tree(parse(g, (*ri).first.c_str()));
        if (next_tree.get() == 0)
            throw bad_regex();
        std::auto_ptr<node> newnode(new or_node(tree.release(), next_tree.release()));
        tree = newnode;
    }


#ifdef BOOST_SPIRIT_DEBUG
    tree->dump(std::cout);
#endif

    // compute followpos(root)
    followpos_t followpos;
    tree->compute_followpos(followpos);

    // the dfa states <-> nfa state groups
    map<node_set, node_id_t> dstates1;
    map<node_id_t, node_set> dstates2;

    // the dfa transitions
    m_dfa.first.push_back(vector<node_id_t>(256, invalid_node));
    m_dfa.second.push_back(invalid_node);

    // whether the dfa state has been processed yet
    vector<node_id_t> marked;

    // used to give a unique id to each dfa state
    node_id_t num_states = 0;

    // initially, the only unmarked state in Dstates is firstpos(root).
    marked.push_back(0);
    node_set fpr = tree->firstpos();
    dstates1[fpr] = 0;
    dstates2[0] = fpr;
    state_match_t state_match;
    tree->compute_state_match(state_match);
    node_set eof_node_ids;
    tree->get_eof_ids(eof_node_ids);
    // translate the eof_node_ids into a 0-based index
    map<node_id_t, node_id_t> eof_node_id_map;
    unsigned int x = 0;
    for (node_set::iterator node_id_it = eof_node_ids.begin();
            node_id_it != eof_node_ids.end();
            ++node_id_it)
    {
        eof_node_id_map[*node_id_it] = x++;
    }
    
    // figure out if this is an acceptance state
    for(node_set::iterator nsi = eof_node_ids.begin();
            nsi != eof_node_ids.end(); ++nsi)
    {
        node_id_t eof_node_id = *nsi;
        if (fpr.find(eof_node_id) != fpr.end())
        {
            // store the first one we come to as the
            // matched pattern
            m_dfa.second[0] = 
                eof_node_id_map[eof_node_id];
            // don't bother searching for more
            break;
        }
    }

    vector<node_id_t>::iterator i = find(marked.begin(), marked.end(), 
            node_id_t(0));
    while (marked.end() != i)
    {
        *i = 1;
        node_id_t T = i - marked.begin();
        assert(T < dstates2.size());
        node_set Tstates = dstates2[T];
        for (node_id_t j = 0; j < 256; ++j)
        {
            node_set U;
            for (node_set::iterator k = Tstates.begin();
                    k != Tstates.end(); ++k)
            {
                node_id_t p = *k;
                assert(p < state_match.size());
                assert(j < state_match[p].size());
                if (state_match[p][j])
                {
                    node_set fpp = followpos[p];
                    U.insert(fpp.begin(), fpp.end());
                }
            }
            if (U.size() > 0)
            {
                map<node_set, node_id_t>::iterator l = dstates1.find(U);
                node_id_t target_state;
                if (l == dstates1.end()) // not in the states yet
                {
                    ++num_states;
                    dstates1[U] = target_state = num_states;
                    dstates2[target_state] = U;
                    marked.push_back(0);
                    m_dfa.first.push_back(
                            vector<node_id_t>(256, invalid_node));
                    m_dfa.second.push_back(invalid_node);
                    // figure out if this is an acceptance state
                    for(node_set::iterator nsi = eof_node_ids.begin();
                            nsi != eof_node_ids.end(); ++nsi)
                    {
                        node_id_t eof_node_id = *nsi;
                        if (U.find(eof_node_id) != U.end())
                        {
                            // store the first one we come to as the
                            // matched pattern
                            m_dfa.second[target_state] = 
                                eof_node_id_map[eof_node_id];
                            // don't bother searching for more
                            break;
                        }
                    }
                }
                else
                {
                    target_state = dstates1[U];
                }

                assert(T < m_dfa.first.size());
                assert(j < m_dfa.first[T].size());
                m_dfa.first[T][j] = target_state;
            }
            
        }

        i = find(marked.begin(), marked.end(), node_id_t(0));
    }
    m_compiled_dfa = true;
}


#ifdef BOOST_SPIRIT_DEBUG
template <typename CharT, typename TokenT>
void
lexer<CharT, TokenT>::dump(std::ostream& out)
{
    out << "\nm_dfa has " << m_dfa.first.size() << " states\n";
    for (node_id_t i = 0; i < m_dfa.first.size(); ++i)
    {
        out << "state " << i << ":";
        for (node_id_t j = 0; j < m_dfa.first[i].size(); ++j)
        {
            if (m_dfa.first[i][j] != invalid_node)
                out << j << "->" << m_dfa.first[i][j] << " ";
        }
        out << "\n";
    }
    out << "acceptance states: ";
    for(unsigned int i = 0; i < m_dfa.second.size(); ++i)
    {
        if (m_dfa.second[i] != invalid_node)
            out << '<' << i << ',' << m_dfa.second[i] << "> ";
    }
    out << endl;
}
#endif

} // namespace spirit

#endif

