<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
 
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
 
  <meta name="GENERATOR" content="Microsoft FrontPage Express 2.0">
  <title>Matrix Proxies</title>
</head>
  <body bgcolor="#ffffff">
  
<h1><img src="c++boost.gif" alt="c++boost.gif" align="Center">
Matrix Proxies</h1>
  
<h2><a name="matrix_row"></a>
Matrix Row</h2>
  
<h4>Description</h4>
  
<p>The templated class <code>matrix_row&lt;M&gt; </code>allows addressing
a row of a matrix.</p>
  
<h4>Example</h4>
  
<pre>#include &lt;boost/numeric/ublas/matrix.hpp&gt;<br>#include &lt;boost/numeric/ublas/io.hpp&gt;<br><br>int main () {<br>    using namespace boost::numeric::ublas;<br>    matrix&lt;double&gt; m (3, 3);<br>    for (unsigned i = 0; i &lt; m.size1 (); ++ i) {<br>        matrix_row&lt;matrix&lt;double&gt; &gt; mr (m, i);<br>        for (unsigned j = 0; j &lt; mr.size (); ++ j)<br>            mr (j) = 3 * i + j;<br>        std::cout &lt;&lt; mr &lt;&lt; std::endl;<br>    }<br>}</pre>
<h4>Definition</h4>
  
<p>Defined in the header matrix_proxy.hpp.</p>
  
<h4>Template parameters</h4>
  
<table border="1">
     <tbody>
    <tr>
         <th>Parameter </th>
         <th>Description </th>
         <th>Default </th>
     </tr>
     <tr>
         <td><code>M</code> </td>
         <td>The type of matrix referenced. </td>
         <td>&nbsp;</td>
     </tr>
 
  </tbody>
</table>
  
<h4>Model of</h4>
  
<p><a href="expression.htm#vector_expression">Vector Expression</a>
. </p>
  
<h4>Type requirements</h4>
  
<p>None, except for those imposed by the requirements of <a href="expression.htm#vector_expression">
Vector Expression</a>
.</p>
  
<h4>Public base classes</h4>
  
<p><code>vector_expression&lt;matrix_row&lt;M&gt; &gt;</code> </p>
  
<h4>Members</h4>
  
<table border="1">
     <tbody>
    <tr>
         <th>Member </th>
         <th>Description </th>
     </tr>
     <tr>
         <td><code>matrix_row (matrix_type &amp;data, size_type i)</code></td>
         <td>Constructs a sub vector.</td>
     </tr>
     <tr>
         <td><code>size_type size () const</code></td>
         <td>Returns the size of the sub vector.</td>
     </tr>
     <tr>
         <td><code>const_reference operator () (size_type i) const</code></td>
         <td>Returns the value of the <code>i</code>-th element. </td>
     </tr>
     <tr>
         <td><code>reference operator () (size_type i)</code></td>
         <td>Returns a reference of the <code>i</code>-th element.      
  </td>
     </tr>
     <tr>
         <td><code>matrix_row &amp;operator = (const matrix_row         &amp;mr)</code></td>
         <td>The assignment operator.</td>
     </tr>
     <tr>
         <td><code>matrix_row &amp;assign_temporary (matrix_row         &amp;mr)</code></td>
         <td>Assigns a temporary. May change the matrix row <code>mr</code>
.</td>
     </tr>
     <tr>
         <td><code>template&lt;class AE&gt;<br>
         matrix_row &amp;operator = (const         vector_expression&lt;AE&gt;
&amp;ae)</code></td>
         <td>The extended assignment operator.</td>
     </tr>
     <tr>
         <td><code>template&lt;class AE&gt;<br>
         matrix_row &amp;assign (const vector_expression&lt;AE&gt;      
  &amp;ae)</code></td>
         <td>Assigns a vector expression to the sub vector. Left        
and right hand side of the assignment should be         independent.</td>
     </tr>
     <tr>
         <td><code>template&lt;class AE&gt;<br>
         matrix_row &amp;operator += (const         vector_expression&lt;AE&gt;
&amp;ae)</code></td>
         <td>A computed assignment operator. Adds the vector         expression
to the sub vector.</td>
     </tr>
     <tr>
         <td><code>template&lt;class AE&gt;<br>
         matrix_row &amp;plus_assign (const         vector_expression&lt;AE&gt;
&amp;ae)</code></td>
         <td>Adds a vector expression to the sub vector. Left and       
 right hand side of the assignment should be independent.</td>
     </tr>
     <tr>
         <td><code>template&lt;class AE&gt;<br>
         matrix_row &amp;operator -= (const         vector_expression&lt;AE&gt;
&amp;ae)</code></td>
         <td>A computed assignment operator. Subtracts the vector       
 expression from the sub vector.</td>
     </tr>
     <tr>
         <td><code>template&lt;class AE&gt;<br>
         matrix_row &amp;minus_assign (const         vector_expression&lt;AE&gt;
&amp;ae)</code></td>
         <td>Subtracts a vector expression from the sub vector.         Left
and right hand side of the assignment should be         independent.</td>
     </tr>
     <tr>
         <td><code>template&lt;class AT&gt;<br>
         matrix_row &amp;operator *= (const AT &amp;at)</code></td>
         <td>A computed assignment operator. Multiplies the sub         vector
with a scalar.</td>
     </tr>
     <tr>
         <td><code>template&lt;class AT&gt;<br>
         matrix_row &amp;operator /= (const AT &amp;at)</code></td>
         <td>A computed assignment operator. Divides the sub         vector
through a scalar.</td>
     </tr>
     <tr>
         <td><code>void swap (matrix_row &amp;mr)</code></td>
         <td>Swaps the contents of the sub vectors. </td>
     </tr>
     <tr>
         <td><code>const_iterator begin () const</code></td>
         <td>Returns a <code>const_iterator</code> pointing to the      
  beginning of the <code>matrix_row</code>. </td>
     </tr>
     <tr>
         <td><code>const_iterator end () const</code></td>
         <td>Returns a <code>const_iterator</code> pointing to the      
  end of the <code>matrix_row</code>. </td>
     </tr>
     <tr>
         <td><code>iterator begin () </code></td>
         <td>Returns a <code>iterator</code> pointing to the         beginning
of the <code>matrix_row</code>. </td>
     </tr>
     <tr>
         <td><code>iterator end () </code></td>
         <td>Returns a <code>iterator</code> pointing to the end        
of the <code>matrix_row</code>. </td>
     </tr>
     <tr>
         <td><code>const_reverse_iterator rbegin () const</code></td>
         <td>Returns a <code>const_reverse_iterator</code>         pointing
to the beginning of the reversed <code>matrix_row</code>.         </td>
     </tr>
     <tr>
         <td><code>const_reverse_iterator rend () const</code></td>
         <td>Returns a <code>const_reverse_iterator</code>         pointing
to the end of the reversed <code>matrix_row</code>.         </td>
     </tr>
     <tr>
         <td><code>reverse_iterator rbegin () </code></td>
         <td>Returns a <code>reverse_iterator</code> pointing to        
the beginning of the reversed <code>matrix_row</code>. </td>
     </tr>
     <tr>
         <td><code>reverse_iterator rend () </code></td>
         <td>Returns a <code>reverse_iterator</code> pointing to        
the end of the reversed <code>matrix_row</code>. </td>
     </tr>
 
  </tbody>
</table>
  
<h4>Interface</h4>
  
<pre><code>    // Matrix based row vector class<br>    template&lt;class M&gt;<br>    class matrix_row:<br>        public vector_expression&lt;matrix_row&lt;M&gt; &gt; {<br>    public:<br>        typedef const M const_matrix_type;<br>        typedef M matrix_type;<br>        typedef typename M::size_type size_type;<br>        typedef typename M::difference_type difference_type;<br>        typedef typename M::value_type value_type;<br>        typedef typename M::const_reference const_reference;<br>        typedef typename M::reference reference;<br>        typedef typename M::const_pointer const_pointer;<br>        typedef typename M::pointer pointer;<br>        typedef const vector_const_reference&lt;const matrix_row&lt;matrix_type&gt; &gt; const_closure_type;<br>        typedef vector_reference&lt;matrix_row&lt;matrix_type&gt; &gt; closure_type;<br>        typedef typename M::const_iterator2 const_iterator_type;<br>        typedef typename M::iterator2 iterator_type;<br>        typedef typename storage_restrict_traits&lt;typename M::storage_category,<br>                                                 dense_proxy_tag&gt;::storage_category storage_category;<br><br>        // Construction and destruction<br>        matrix_row ();<br>        matrix_row (matrix_type &amp;data, size_type i);<br><br>        // Accessors<br>        size_type size () const;<br>        const_matrix_type &amp;data () const;<br>        matrix_type &amp;data ();<br><br><br>        // Element access<br>        const_reference operator () (size_type j) const;<br>        reference operator () (size_type j);<br><br>        const_reference operator [] (size_type j) const;<br>        reference operator [] (size_type j);<br><br>        // Assignment<br>        matrix_row &amp;operator = (const matrix_row &amp;mr);<br>        matrix_row &amp;assign_temporary (matrix_row &amp;mr);<br>        template&lt;class AE&gt;<br>        matrix_row &amp;operator = (const vector_expression&lt;AE&gt; &amp;ae);<br>        template&lt;class AE&gt;<br>        matrix_row &amp;assign (const vector_expression&lt;AE&gt; &amp;ae);<br>        template&lt;class AE&gt;<br>        matrix_row &amp;operator += (const vector_expression&lt;AE&gt; &amp;ae);<br>        template&lt;class AE&gt;<br>        matrix_row &amp;plus_assign (const vector_expression&lt;AE&gt; &amp;ae);<br>        template&lt;class AE&gt;<br>        matrix_row &amp;operator -= (const vector_expression&lt;AE&gt; &amp;ae);<br>        template&lt;class AE&gt;<br>        matrix_row &amp;minus_assign (const vector_expression&lt;AE&gt; &amp;ae);<br>        template&lt;class AT&gt;<br>        matrix_row &amp;operator *= (const AT &amp;at);<br>        template&lt;class AT&gt;<br>        matrix_row &amp;operator /= (const AT &amp;at);<br><br>        // Swapping<br>        void swap (matrix_row &amp;mr);<br>        friend void swap (matrix_row &amp;mr1, matrix_row &amp;mr2);<br><br>        class const_iterator;<br>        class iterator;<br><br>        // Element lookup<br>        const_iterator find_first (size_type j) const;<br>        iterator find_first (size_type j);<br>        const_iterator find_last (size_type j) const;<br>        iterator find_last (size_type j);<br><br>        // Iterators simply are pointers.<br><br>        class const_iterator:<br>            public container_const_reference&lt;matrix_row&gt;,<br>            public random_access_iterator_base&lt;const_iterator, value_type&gt; {<br>        public:<br>            typedef typename const_iterator_type::iterator_category iterator_category;<br>            typedef typename const_iterator_type::difference_type difference_type;<br>            typedef typename const_iterator_type::value_type value_type;<br>            typedef typename const_iterator_type::reference reference;<br>            typedef typename const_iterator_type::pointer pointer;<br><br>            // Construction and destruction<br>            const_iterator ();<br>            const_iterator (const matrix_row &amp;mr, const const_iterator_type &amp;it);<br>            const_iterator (const iterator &amp;it);<br><br>            // Arithmetic<br>            const_iterator &amp;operator ++ ();<br>            const_iterator &amp;operator -- ();<br>            const_iterator &amp;operator += (difference_type n);<br>            const_iterator &amp;operator -= (difference_type n);<br>            difference_type operator - (const const_iterator &amp;it) const;<br><br>            // Dereference<br>            reference operator * () const;<br><br>            // Index<br>            size_type index () const;<br><br>            // Assignment <br>            const_iterator &amp;operator = (const const_iterator &amp;it);<br><br>            // Comparison<br>            bool operator == (const const_iterator &amp;it) const;<br>            bool operator &lt;(const const_iterator &amp;it) const;<br>        };<br><br>        const_iterator begin () const;<br>        const_iterator end () const;<br><br>        class iterator:<br>            public container_reference&lt;matrix_row&gt;,<br>            public random_access_iterator_base&lt;iterator, value_type&gt; {<br>        public:<br>            typedef typename iterator_type::iterator_category iterator_category;<br>            typedef typename iterator_type::difference_type difference_type;<br>            typedef typename iterator_type::value_type value_type;<br>            typedef typename iterator_type::reference reference;<br>            typedef typename iterator_type::pointer pointer;<br><br>            // Construction and destruction<br>            iterator ();<br>            iterator (matrix_row &amp;mr, const iterator_type &amp;it);<br><br>            // Arithmetic<br>            iterator &amp;operator ++ ();<br>            iterator &amp;operator -- ();<br>            iterator &amp;operator += (difference_type n);<br>            iterator &amp;operator -= (difference_type n);<br>            difference_type operator - (const iterator &amp;it) const;<br><br>            // Dereference<br>            reference operator * () const;<br><br>            // Index<br>            size_type index () const;<br><br>            // Assignment <br>            iterator &amp;operator = (const iterator &amp;it);<br><br>            // Comparison<br>            bool operator == (const iterator &amp;it) const;<br>            bool operator &lt;(const iterator &amp;it) const;<br>        };<br><br>        iterator begin ();<br>        iterator end ();<br><br>        // Reverse iterator<br><br>        typedef reverse_iterator_base&lt;const_iterator&gt; const_reverse_iterator;<br><br>        const_reverse_iterator rbegin () const;<br>        const_reverse_iterator rend () const;<br><br>        typedef reverse_iterator_base&lt;iterator&gt; reverse_iterator;<br><br>        reverse_iterator rbegin ();<br>        reverse_iterator rend ();<br>    };</code></pre>
  
<h3>Projections</h3>
  
<h4>Prototypes</h4>
  
<pre><code>    template&lt;class M&gt;<br>    matrix_row&lt;M&gt; row (M &amp;data, std::size_t i);<br>    template&lt;class M&gt;<br>    const matrix_row&lt;const M&gt; row (const M &amp;data, std::size_t i);</code></pre>
  
<h4>Description</h4>
  
<p>The free <code>row</code> functions support the construction of matrix
rows.</p>
  
<h4>Definition</h4>
  
<p>Defined in the header matrix_proxy.hpp.</p>
  
<h4>Type requirements</h4>
  
<dir>     <li><code>M</code> is a model of <a href="expression.htm#matrix_expression">
Matrix Expression</a>
.</li>
 </dir>
  
<h4>Preconditions</h4>
  
<ul type="Disc">
     <li><code>i &lt; data.size1 ()</code></li>
 
</ul>
  
<h4>Complexity</h4>
  
<p>Linear depending from the size of the row.</p>
  
<h4>Examples</h4>
  
<pre>#include &lt;boost/numeric/ublas/matrix.hpp&gt;<br>#include &lt;boost/numeric/ublas/io.hpp&gt;<br><br>int main () {<br>    using namespace boost::numeric::ublas;<br>    matrix&lt;double&gt; m (3, 3);<br>    for (unsigned i = 0; i &lt; m.size1 (); ++ i) {<br>        for (unsigned j = 0; j &lt; m.size2 (); ++ j)<br>            row (m, i) (j) = 3 * i + j;<br>        std::cout &lt;&lt; row (m, i) &lt;&lt; std::endl;<br>    }<br>}<br></pre>
<h2><a name="matrix_column"></a>
Matrix Column</h2>
  
<h4>Description</h4>
  
<p>The templated class <code>matrix_column&lt;M&gt; </code>allows addressing
a column of a matrix.</p>
  
<h4>Example</h4>
  
<pre>#include &lt;boost/numeric/ublas/matrix.hpp&gt;<br>#include &lt;boost/numeric/ublas/io.hpp&gt;<br><br>int main () {<br>    using namespace boost::numeric::ublas;<br>    matrix&lt;double&gt; m (3, 3);<br>    for (unsigned j = 0; j &lt; m.size2 (); ++ j) {<br>        matrix_column&lt;matrix&lt;double&gt; &gt; mc (m, j);<br>        for (unsigned i = 0; i &lt; mc.size (); ++ i)<br>            mc (i) = 3 * i + j;<br>        std::cout &lt;&lt; mc &lt;&lt; std::endl;<br>    }<br>}<br></pre>
<h4>Definition</h4>
  
<p>Defined in the header matrix_proxy.hpp.</p>
  
<h4>Template parameters</h4>
  
<table border="1">
     <tbody>
    <tr>
         <th>Parameter </th>
         <th>Description </th>
         <th>Default </th>
     </tr>
     <tr>
         <td><code>M</code> </td>
         <td>The type of matrix referenced. </td>
         <td>&nbsp;</td>
     </tr>
 
  </tbody>
</table>
  
<h4>Model of</h4>
  
<p><a href="expression.htm#vector_expression">Vector Expression</a>
. </p>
  
<h4>Type requirements</h4>
  
<p>None, except for those imposed by the requirements of <a href="expression.htm#vector_expression">
Vector Expression</a>
.</p>
  
<h4>Public base classes</h4>
  
<p><code>vector_expression&lt;matrix_column&lt;M&gt; &gt;</code> </p>
  
<h4>Members</h4>
  
<table border="1">
     <tbody>
    <tr>
         <th>Member </th>
         <th>Description </th>
     </tr>
     <tr>
         <td><code>matrix_column (matrix_type &amp;data, size_type      
  j)</code></td>
         <td>Constructs a sub vector.</td>
     </tr>
     <tr>
         <td><code>size_type size () const</code></td>
         <td>Returns the size of the sub vector.</td>
     </tr>
     <tr>
         <td><code>const_reference operator () (size_type i) const</code></td>
         <td>Returns the value of the <code>i</code>-th element. </td>
     </tr>
     <tr>
         <td><code>reference operator () (size_type i)</code></td>
         <td>Returns a reference of the <code>i</code>-th element.      
  </td>
     </tr>
     <tr>
         <td><code>matrix_column &amp;operator = (const         matrix_column
&amp;mc)</code></td>
         <td>The assignment operator.</td>
     </tr>
     <tr>
         <td><code>matrix_column &amp;assign_temporary         (matrix_column
&amp;mc)</code></td>
         <td>Assigns a temporary. May change the matrix column <code>mc</code>
.</td>
     </tr>
     <tr>
         <td><code>template&lt;class AE&gt;<br>
         matrix_column &amp;operator = (const         vector_expression&lt;AE&gt;
&amp;ae)</code></td>
         <td>The extended assignment operator.</td>
     </tr>
     <tr>
         <td><code>template&lt;class AE&gt;<br>
         matrix_column &amp;assign (const         vector_expression&lt;AE&gt;
&amp;ae)</code></td>
         <td>Assigns a vector expression to the sub vector. Left        
and right hand side of the assignment should be         independent.</td>
     </tr>
     <tr>
         <td><code>template&lt;class AE&gt;<br>
         matrix_column &amp;operator += (const         vector_expression&lt;AE&gt;
&amp;ae)</code></td>
         <td>A computed assignment operator. Adds the vector         expression
to the sub vector.</td>
     </tr>
     <tr>
         <td><code>template&lt;class AE&gt;<br>
         matrix_column &amp;plus_assign (const         vector_expression&lt;AE&gt;
&amp;ae)</code></td>
         <td>Adds a vector expression to the sub vector. Left and       
 right hand side of the assignment should be independent.</td>
     </tr>
     <tr>
         <td><code>template&lt;class AE&gt;<br>
         matrix_column &amp;operator -= (const         vector_expression&lt;AE&gt;
&amp;ae)</code></td>
         <td>A computed assignment operator. Subtracts the vector       
 expression from the sub vector.</td>
     </tr>
     <tr>
         <td><code>template&lt;class AE&gt;<br>
         matrix_column &amp;minus_assign (const         vector_expression&lt;AE&gt;
&amp;ae)</code></td>
         <td>Subtracts a vector expression from the sub vector.         Left
and right hand side of the assignment should be         independent.</td>
     </tr>
     <tr>
         <td><code>template&lt;class AT&gt;<br>
         matrix_column &amp;operator *= (const AT &amp;at)</code></td>
         <td>A computed assignment operator. Multiplies the sub         vector
with a scalar.</td>
     </tr>
     <tr>
         <td><code>template&lt;class AT&gt;<br>
         matrix_column &amp;operator /= (const AT &amp;at)</code></td>
         <td>A computed assignment operator. Divides the sub         vector
through a scalar.</td>
     </tr>
     <tr>
         <td><code>void swap (matrix_column &amp;mc)</code></td>
         <td>Swaps the contents of the sub vectors. </td>
     </tr>
     <tr>
         <td><code>const_iterator begin () const</code></td>
         <td>Returns a <code>const_iterator</code> pointing to the      
  beginning of the <code>matrix_column</code>. </td>
     </tr>
     <tr>
         <td><code>const_iterator end () const</code></td>
         <td>Returns a <code>const_iterator</code> pointing to the      
  end of the <code>matrix_column</code>. </td>
     </tr>
     <tr>
         <td><code>iterator begin () </code></td>
         <td>Returns a <code>iterator</code> pointing to the         beginning
of the <code>matrix_column</code>. </td>
     </tr>
     <tr>
         <td><code>iterator end () </code></td>
         <td>Returns a <code>iterator</code> pointing to the end        
of the <code>matrix_column</code>. </td>
     </tr>
     <tr>
         <td><code>const_reverse_iterator rbegin () const</code></td>
         <td>Returns a <code>const_reverse_iterator</code>         pointing
to the beginning of the reversed <code>matrix_column</code>.         </td>
     </tr>
     <tr>
         <td><code>const_reverse_iterator rend () const</code></td>
         <td>Returns a <code>const_reverse_iterator</code>         pointing
to the end of the reversed <code>matrix_column</code>.         </td>
     </tr>
     <tr>
         <td><code>reverse_iterator rbegin () </code></td>
         <td>Returns a <code>reverse_iterator</code> pointing to        
the beginning of the reversed <code>matrix_column</code>.         </td>
     </tr>
     <tr>
         <td><code>reverse_iterator rend () </code></td>
         <td>Returns a <code>reverse_iterator</code> pointing to        
the end of the reversed <code>matrix_column</code>. </td>
     </tr>
 
  </tbody>
</table>
  
<h4>Interface</h4>
  
<pre><code>    // Matrix based column vector class<br>    template&lt;class M&gt;<br>    class matrix_column:<br>        public vector_expression&lt;matrix_column&lt;M&gt; &gt; {<br>    public:      <br>        typedef const M const_matrix_type;<br>        typedef M matrix_type;<br>        typedef typename M::size_type size_type;<br>        typedef typename M::difference_type difference_type;<br>        typedef typename M::value_type value_type;<br>        typedef typename M::const_reference const_reference;<br>        typedef typename M::reference reference;<br>        typedef typename M::const_pointer const_pointer;<br>        typedef typename M::pointer pointer;<br>        typedef const vector_const_reference&lt;const matrix_column&lt;matrix_type&gt; &gt; const_closure_type;<br>        typedef vector_reference&lt;matrix_column&lt;matrix_type&gt; &gt; closure_type;<br>        typedef typename M::const_iterator1 const_iterator_type;<br>        typedef typename M::iterator1 iterator_type;<br>        typedef typename storage_restrict_traits&lt;typename M::storage_category,<br>                                                 dense_proxy_tag&gt;::storage_category storage_category;<br><br>        // Construction and destruction<br>        matrix_column ();<br>        matrix_column (matrix_type &amp;data, size_type j);<br><br>        // Accessors<br>        size_type size () const;<br>        const_matrix_type &amp;data () const;<br>        matrix_type &amp;data ();<br><br><br>        // Element access<br>        const_reference operator () (size_type i) const;<br>        reference operator () (size_type i);<br><br>        const_reference operator [] (size_type i) const;<br>        reference operator [] (size_type i);<br><br>        // Assignment<br>        matrix_column &amp;operator = (const matrix_column &amp;mc);<br>        matrix_column &amp;assign_temporary (matrix_column &amp;mc);<br>        template&lt;class AE&gt;<br>        matrix_column &amp;operator = (const vector_expression&lt;AE&gt; &amp;ae);<br>        template&lt;class AE&gt;<br>        matrix_column &amp;assign (const vector_expression&lt;AE&gt; &amp;ae);<br>        template&lt;class AE&gt;<br>        matrix_column &amp;operator += (const vector_expression&lt;AE&gt; &amp;ae);<br>        template&lt;class AE&gt;<br>        matrix_column &amp;plus_assign (const vector_expression&lt;AE&gt; &amp;ae);<br>        template&lt;class AE&gt;<br>        matrix_column &amp;operator -= (const vector_expression&lt;AE&gt; &amp;ae);<br>        template&lt;class AE&gt;<br>        matrix_column &amp;minus_assign (const vector_expression&lt;AE&gt; &amp;ae);<br>        template&lt;class AT&gt;<br>        matrix_column &amp;operator *= (const AT &amp;at);<br>        template&lt;class AT&gt;<br>        matrix_column &amp;operator /= (const AT &amp;at);<br><br>        // Swapping<br>        void swap (matrix_column &amp;mc);<br>        friend void swap (matrix_column &amp;mc1, matrix_column &amp;mc2);<br><br>        class const_iterator;<br>        class iterator;<br><br>        // Element lookup<br>        const_iterator find_first (size_type i) const;<br>        iterator find_first (size_type i);<br>        const_iterator find_last (size_type i) const;<br>        iterator find_last (size_type i);<br><br>        // Iterators simply are pointers.<br><br>        class const_iterator:<br>            public container_const_reference&lt;matrix_column&gt;,<br>            public random_access_iterator_base&lt;const_iterator, value_type&gt; {<br>        public:<br>            typedef typename const_iterator_type::iterator_category iterator_category;<br>            typedef typename const_iterator_type::difference_type difference_type;<br>            typedef typename const_iterator_type::value_type value_type;<br>            typedef typename const_iterator_type::reference reference;<br>            typedef typename const_iterator_type::pointer pointer;<br><br>            // Construction and destruction<br>            const_iterator ();<br>            const_iterator (const matrix_column &amp;mc, const const_iterator_type &amp;it);<br>            const_iterator (const iterator &amp;it);<br><br>            // Arithmetic<br>            const_iterator &amp;operator ++ ();<br>            const_iterator &amp;operator -- ();<br>            const_iterator &amp;operator += (difference_type n);<br>            const_iterator &amp;operator -= (difference_type n);<br>            difference_type operator - (const const_iterator &amp;it) const;<br><br>            // Dereference<br>            reference operator * () const;<br><br>            // Index<br>            size_type index () const;<br><br>            // Assignment<br>            const_iterator &amp;operator = (const const_iterator &amp;it);<br><br>            // Comparison<br>            bool operator == (const const_iterator &amp;it) const;<br>            bool operator &lt;(const const_iterator &amp;it) const;<br>        };<br><br>        const_iterator begin () const;<br>        const_iterator end () const;<br><br>        class iterator:<br>            public container_reference&lt;matrix_column&gt;,<br>            public random_access_iterator_base&lt;iterator, value_type&gt; {<br>        public:<br>            typedef typename iterator_type::iterator_category iterator_category;<br>            typedef typename iterator_type::difference_type difference_type;<br>            typedef typename iterator_type::value_type value_type;<br>            typedef typename iterator_type::reference reference;<br>            typedef typename iterator_type::pointer pointer;<br><br>            // Construction and destruction<br>            iterator ();<br>            iterator (matrix_column &amp;mc, const iterator_type &amp;it);<br><br>            // Arithmetic<br>            iterator &amp;operator ++ ();<br>            iterator &amp;operator -- ();<br>            iterator &amp;operator += (difference_type n);<br>            iterator &amp;operator -= (difference_type n);<br>            difference_type operator - (const iterator &amp;it) const;<br><br>            // Dereference<br>            reference operator * () const;<br><br>            // Index<br>            size_type index () const;<br><br>            // Assignment <br>            iterator &amp;operator = (const iterator &amp;it);<br><br>            // Comparison<br>            bool operator == (const iterator &amp;it) const;<br>            bool operator &lt;(const iterator &amp;it) const;<br>        };<br><br>        iterator begin ();<br>        iterator end ();<br><br>        // Reverse iterator<br><br>        typedef reverse_iterator_base&lt;const_iterator&gt; const_reverse_iterator;<br><br>        const_reverse_iterator rbegin () const;<br>        const_reverse_iterator rend () const;<br><br>        typedef reverse_iterator_base&lt;iterator&gt; reverse_iterator;<br><br>        reverse_iterator rbegin ();<br>        reverse_iterator rend ();<br>    };</code></pre>
  
<h3>Projections</h3>
  
<h4>Prototypes</h4>
  
<pre><code>    template&lt;class M&gt;<br>    matrix_column&lt;M&gt; column (M &amp;data, std::size_t j);<br>    template&lt;class M&gt;<br>    const matrix_column&lt;const M&gt; column (const M &amp;data, std::size_t j);</code></pre>
  
<h4>Description</h4>
  
<p>The free <code>column</code> functions support the construction of matrix
columns.</p>
  
<h4>Definition</h4>
  
<p>Defined in the header matrix_proxy.hpp.</p>
  
<h4>Type requirements</h4>
  
<dir>     <li><code>M</code> is a model of <a href="expression.htm#matrix_expression">
Matrix Expression</a>
.</li>
 </dir>
  
<h4>Preconditions</h4>
  
<ul type="Disc">
     <li><code>j &lt; data.size2 ()</code></li>
 
</ul>
  
<h4>Complexity</h4>
  
<p>Linear depending from the size of the column.</p>
  
<h4>Examples</h4>
  
<pre>#include &lt;boost/numeric/ublas/matrix.hpp&gt;<br>#include &lt;boost/numeric/ublas/io.hpp&gt;<br><br>int main () {<br>    using namespace boost::numeric::ublas;<br>    matrix&lt;double&gt; m (3, 3);<br>    for (unsigned j = 0; j &lt; m.size2 (); ++ j) {<br>        for (unsigned i = 0; i &lt; m.size1 (); ++ i)<br>            column (m, j) (i) = 3 * i + j;<br>        std::cout &lt;&lt; column (m, j) &lt;&lt; std::endl;<br>    }<br>}<br></pre>
<h2><a name="vector_range"></a>
Vector Range</h2>
  
<h4>Description</h4>
  
<p>The templated class <code>matrix_vector_range&lt;M&gt; </code>allows addressing
a sub vector of a matrix.</p>
  
<h4>Example</h4>
  
<pre>#include &lt;boost/numeric/ublas/matrix.hpp&gt;<br>#include &lt;boost/numeric/ublas/io.hpp&gt;<br><br>int main () {<br>    using namespace boost::numeric::ublas;<br>    matrix&lt;double&gt; m (3, 3);<br>    for (unsigned i = 0; i &lt; m.size1 (); ++ i)<br>        for (unsigned j = 0; j &lt; m.size2 (); ++ j)<br>            m (i, j) = 3 * i + j;<br><br>    matrix_vector_range&lt;matrix&lt;double&gt; &gt; mvr (m, range (0, 3), range (0, 3));<br>    std::cout &lt;&lt; mvr &lt;&lt; std::endl;<br>}<br></pre>
<h4>Definition</h4>
  
<p>Defined in the header matrix_proxy.hpp.</p>
  
<h4>Template parameters</h4>
  
<table border="1">
     <tbody>
    <tr>
         <th>Parameter </th>
         <th>Description </th>
         <th>Default </th>
     </tr>
     <tr>
         <td><code>M</code> </td>
         <td>The type of matrix referenced. </td>
         <td>&nbsp;</td>
     </tr>
 
  </tbody>
</table>
  
<h4>Model of</h4>
  
<p><a href="expression.htm#vector_expression">Vector Expression</a>
.</p>
  
<h4>Type requirements</h4>
  
<p>None, except for those imposed by the requirements of <a href="expression.htm#vector_expression">
Vector Expression</a>
.</p>
  
<h4>Public base classes</h4>
  
<p><code>vector_expression&lt;matrix_vector_range&lt;M&gt; &gt;</code> </p>
  
<h4>Members</h4>
  
<table border="1">
     <tbody>
    <tr>
         <th>Member </th>
         <th>Description </th>
     </tr>
     <tr>
         <td><code>matrix_vector_range (matrix_type &amp;data,<br>
         &nbsp;const range &amp;r1, const range &amp;r2)</code></td>
         <td>Constructs a sub vector.</td>
     </tr>
     <tr>
         <td><code>size_type size () const</code></td>
         <td>Returns the size of the sub vector.</td>
     </tr>
     <tr>
         <td><code>const_reference operator () (size_type i) const</code></td>
         <td>Returns the value of the <code>i</code>-th element. </td>
     </tr>
     <tr>
         <td><code>reference operator () (size_type i)</code></td>
         <td>Returns a reference of the <code>i</code>-th element.      
  </td>
     </tr>
     <tr>
         <td><code>matrix_vector_range &amp;operator = (const         matrix_vector_range
&amp;mvr)</code></td>
         <td>The assignment operator.</td>
     </tr>
     <tr>
         <td><code>matrix_vector_range &amp;assign_temporary         (matrix_vector_range
&amp;mvr)</code></td>
         <td>Assigns a temporary. May change the matrix vector         range
      <code>mvr</code>.</td>
     </tr>
     <tr>
         <td><code>template&lt;class AE&gt;<br>
         matrix_vector_range &amp;operator = (const         vector_expression&lt;AE&gt;
&amp;ae)</code></td>
         <td>The extended assignment operator.</td>
     </tr>
     <tr>
         <td><code>template&lt;class AE&gt;<br>
         matrix_vector_range &amp;assign (const         vector_expression&lt;AE&gt;
&amp;ae)</code></td>
         <td>Assigns a vector expression to the sub vector. Left        
and right hand side of the assignment should be         independent.</td>
     </tr>
     <tr>
         <td><code>template&lt;class AE&gt;<br>
         matrix_vector_range &amp;operator += (const         vector_expression&lt;AE&gt;
&amp;ae)</code></td>
         <td>A computed assignment operator. Adds the vector         expression
to the sub vector.</td>
     </tr>
     <tr>
         <td><code>template&lt;class AE&gt;<br>
         matrix_vector_range &amp;plus_assign (const         vector_expression&lt;AE&gt;
&amp;ae)</code></td>
         <td>Adds a vector expression to the sub vector. Left and       
 right hand side of the assignment should be independent.</td>
     </tr>
     <tr>
         <td><code>template&lt;class AE&gt;<br>
         matrix_vector_range &amp;operator -= (const         vector_expression&lt;AE&gt;
&amp;ae)</code></td>
         <td>A computed assignment operator. Subtracts the vector       
 expression from the sub vector.</td>
     </tr>
     <tr>
         <td><code>template&lt;class AE&gt;<br>
         matrix_vector_range &amp;minus_assign (const         vector_expression&lt;AE&gt;
&amp;ae)</code></td>
         <td>Subtracts a vector expression from the sub vector.         Left
and right hand side of the assignment should be         independent.</td>
     </tr>
     <tr>
         <td><code>template&lt;class AT&gt;<br>
         matrix_vector_range &amp;operator *= (const AT &amp;at)</code></td>
         <td>A computed assignment operator. Multiplies the sub         vector
with a scalar.</td>
     </tr>
     <tr>
         <td><code>template&lt;class AT&gt;<br>
         matrix_vector_range &amp;operator /= (const AT &amp;at)</code></td>
         <td>A computed assignment operator. Divides the sub         vector
through a scalar.</td>
     </tr>
     <tr>
         <td><code>void swap (matrix_vector_range &amp;mvr)</code></td>
         <td>Swaps the contents of the sub vectors. </td>
     </tr>
     <tr>
         <td><code>const_iterator begin () const</code></td>
         <td>Returns a <code>const_iterator</code> pointing to the      
  beginning of the <code>matrix_vector_range</code>. </td>
     </tr>
     <tr>
         <td><code>const_iterator end () const</code></td>
         <td>Returns a <code>const_iterator</code> pointing to the      
  end of the <code>matrix_vector_range</code>. </td>
     </tr>
     <tr>
         <td><code>iterator begin () </code></td>
         <td>Returns a <code>iterator</code> pointing to the         beginning
of the <code>matrix_vector_range</code>. </td>
     </tr>
     <tr>
         <td><code>iterator end () </code></td>
         <td>Returns a <code>iterator</code> pointing to the end        
of the <code>matrix_vector_range</code>. </td>
     </tr>
     <tr>
         <td><code>const_reverse_iterator rbegin () const</code></td>
         <td>Returns a <code>const_reverse_iterator</code>         pointing
to the beginning of the <code>matrix_vector_range</code>.         </td>
     </tr>
     <tr>
         <td><code>const_reverse_iterator rend () const</code></td>
         <td>Returns a <code>const_reverse_iterator</code>         pointing
to the end of the reversed <code>matrix_vector_range</code>.         </td>
     </tr>
     <tr>
         <td><code>reverse_iterator rbegin () </code></td>
         <td>Returns a <code>reverse_iterator</code> pointing to        
the beginning of the reversed <code>matrix_vector_range</code>.         </td>
     </tr>
     <tr>
         <td><code>reverse_iterator rend () </code></td>
         <td>Returns a <code>reverse_iterator</code> pointing to        
the end of the reversed <code>matrix_vector_range</code>.         </td>
     </tr>
 
  </tbody>
</table>
  
<h4>Interface</h4>
  
<pre><code>    // Matrix based vector range class<br>    template&lt;class M&gt;<br>    class matrix_vector_range:<br>        public vector_expression&lt;matrix_vector_range&lt;M&gt; &gt; {<br>    public:      <br>        typedef const M const_matrix_type;<br>        typedef M matrix_type;<br>        typedef typename M::size_type size_type;<br>        typedef typename M::difference_type difference_type;<br>        typedef typename M::value_type value_type;<br>        typedef typename M::const_reference const_reference;<br>        typedef typename M::reference reference;<br>        typedef typename M::const_pointer const_pointer;<br>        typedef typename M::pointer pointer;<br>        typedef const vector_const_reference&lt;const matrix_vector_range&lt;matrix_type&gt; &gt; const_closure_type;<br>        typedef vector_reference&lt;matrix_vector_range&lt;matrix_type&gt; &gt; closure_type;<br>        typedef range::const_iterator const_iterator1_type;<br>        typedef range::const_iterator iterator1_type;<br>        typedef range::const_iterator const_iterator2_type;<br>        typedef range::const_iterator iterator2_type;<br>        typedef typename storage_restrict_traits&lt;typename M::storage_category,<br>                                                 dense_proxy_tag&gt;::storage_category storage_category;<br><br>        // Construction and destruction<br>        matrix_vector_range ();<br>        matrix_vector_range (matrix_type &amp;data, const range &amp;r1, const range &amp;r2);<br><br>        // Accessors<br>        size_type size () const;<br>        const_matrix_type &amp;data () const;<br>        matrix_type &amp;data ();<br><br><br>        // Element access<br>        const_reference operator () (size_type i) const;<br>        reference operator () (size_type i);<br><br>        const_reference operator [] (size_type i) const;<br>        reference operator [] (size_type i);<br><br>        // Assignment<br>        matrix_vector_range &amp;operator = (const matrix_vector_range &amp;mvr);<br>        matrix_vector_range &amp;assign_temporary (matrix_vector_range &amp;mvr);<br>        template&lt;class AE&gt;<br>        matrix_vector_range &amp;operator = (const vector_expression&lt;AE&gt; &amp;ae);<br>        template&lt;class AE&gt;<br>        matrix_vector_range &amp;assign (const vector_expression&lt;AE&gt; &amp;ae);<br>        template&lt;class AE&gt;<br>        matrix_vector_range &amp;operator += (const vector_expression&lt;AE&gt; &amp;ae);<br>        template&lt;class AE&gt;<br>        matrix_vector_range &amp;plus_assign (const vector_expression&lt;AE&gt; &amp;ae);<br>        template&lt;class AE&gt;<br>        matrix_vector_range &amp;operator -= (const vector_expression&lt;AE&gt; &amp;ae);<br>        template&lt;class AE&gt;<br>        matrix_vector_range &amp;minus_assign (const vector_expression&lt;AE&gt; &amp;ae);<br>        template&lt;class AT&gt;<br>        matrix_vector_range &amp;operator *= (const AT &amp;at);<br>        template&lt;class AT&gt;<br>        matrix_vector_range &amp;operator /= (const AT &amp;at);<br><br>        // Swapping<br>        void swap (matrix_vector_range &amp;mvr);<br>        friend void swap (matrix_vector_range &amp;mvr1, matrix_vector_range &amp;mvr2);<br><br>        class const_iterator;<br>        class iterator;<br><br>        // Element lookup<br>        const_iterator find_first (size_type i) const;<br>        iterator find_first (size_type i);<br>        const_iterator find_last (size_type i) const;<br>        iterator find_last (size_type i);<br><br>        // Iterators simply are indices.<br><br>        class const_iterator:<br>            public container_const_reference&lt;matrix_vector_range&gt;,<br>            public random_access_iterator_base&lt;const_iterator, value_type&gt; {<br>        public:<br>            typedef typename restrict_traits&lt;typename M::const_iterator1::iterator_category,<br>                                             typename M::const_iterator2::iterator_category&gt;::iterator_category iterator_category; <br>            typedef typename matrix_vector_range::difference_type difference_type;<br>            typedef typename matrix_vector_range::value_type value_type;<br>            typedef typename matrix_vector_range::const_reference reference;<br>            typedef typename matrix_vector_range::const_pointer pointer;<br><br>            // Construction and destruction<br>            const_iterator ();<br>            const_iterator (const matrix_vector_range &amp;mvr, const const_iterator1_type &amp;it1, const const_iterator2_type &amp;it2);<br>            const_iterator (const iterator &amp;it);<br><br>            // Arithmetic<br>            const_iterator &amp;operator ++ ();<br>            const_iterator &amp;operator -- ();<br>            const_iterator &amp;operator += (difference_type n);<br>            const_iterator &amp;operator -= (difference_type n);<br>            difference_type operator - (const const_iterator &amp;it) const;<br><br>            // Dereference<br>            reference operator * () const;<br><br>            // Index<br>            size_type  index () const;<br><br>            // Assignment <br>            const_iterator &amp;operator = (const const_iterator &amp;it);<br><br>            // Comparison<br>            bool operator == (const const_iterator &amp;it) const;<br>            bool operator &lt;(const const_iterator &amp;it) const;<br>        };<br><br>        const_iterator begin () const;<br>        const_iterator end () const;<br><br>        class iterator:<br>            public container_reference&lt;matrix_vector_range&gt;,<br>            public random_access_iterator_base&lt;iterator, value_type&gt; {<br>        public:<br>            typedef typename restrict_traits&lt;typename M::iterator1::iterator_category,<br>                                             typename M::iterator2::iterator_category&gt;::iterator_category iterator_category; <br>            typedef typename matrix_vector_range::difference_type difference_type;<br>            typedef typename matrix_vector_range::value_type value_type;<br>            typedef typename matrix_vector_range::reference reference;<br>            typedef typename matrix_vector_range::pointer pointer;<br><br>            // Construction and destruction<br>            iterator ();<br>            iterator (matrix_vector_range &amp;mvr, const iterator1_type &amp;it1, const iterator2_type &amp;it2);<br><br>            // Arithmetic<br>            iterator &amp;operator ++ ();<br>            iterator &amp;operator -- ();<br>            iterator &amp;operator += (difference_type n);<br>            iterator &amp;operator -= (difference_type n);<br>            difference_type operator - (const iterator &amp;it) const;<br><br>            // Dereference<br>            reference operator * () const;<br><br>            // Index<br>            size_type index () const;<br><br>            // Assignment <br>            iterator &amp;operator = (const iterator &amp;it);<br><br>            // Comparison<br>            bool operator == (const iterator &amp;it) const;<br>            bool operator &lt;(const iterator &amp;it) const;<br>        };<br><br>        iterator begin ();<br>        iterator end ();<br><br>        // Reverse iterator<br><br>        typedef reverse_iterator_base&lt;const_iterator&gt; const_reverse_iterator;<br><br>        const_reverse_iterator rbegin () const;<br>        const_reverse_iterator rend () const;<br><br>        typedef reverse_iterator_base&lt;iterator&gt; reverse_iterator;<br><br>        reverse_iterator rbegin ();<br>        reverse_iterator rend ();<br>    };</code></pre>
  
<h2><a name="vector_slice"></a>
Vector Slice</h2>
  
<h4>Description</h4>
  
<p>The templated class <code>matrix_vector_slice&lt;M&gt; </code>allows addressing
a sliced sub vector of a matrix.</p>
  
<h4>Example</h4>
  
<pre>#include &lt;boost/numeric/ublas/matrix.hpp&gt;<br>#include &lt;boost/numeric/ublas/io.hpp&gt;<br><br>int main () {<br>    using namespace boost::numeric::ublas;<br>    matrix&lt;double&gt; m (3, 3);<br>    for (unsigned i = 0; i &lt; m.size1 (); ++ i)<br>        for (unsigned j = 0; j &lt; m.size2 (); ++ j)<br>            m (i, j) = 3 * i + j;<br><br>    matrix_vector_slice&lt;matrix&lt;double&gt; &gt; mvs (m, slice (0, 1, 3), slice (0, 1, 3));<br>    std::cout &lt;&lt; mvs &lt;&lt; std::endl;<br>}</pre>
<h4>Definition</h4>
  
<p>Defined in the header matrix_proxy.hpp.</p>
  
<h4>Template parameters</h4>
  
<table border="1">
     <tbody>
    <tr>
         <th>Parameter </th>
         <th>Description </th>
         <th>Default </th>
     </tr>
     <tr>
         <td><code>M</code> </td>
         <td>The type of matrix referenced. </td>
         <td>&nbsp;</td>
     </tr>
 
  </tbody>
</table>
  
<h4>Model of</h4>
  
<p><a href="expression.htm#vector_expression">Vector Expression</a>
.</p>
  
<h4>Type requirements</h4>
  
<p>None, except for those imposed by the requirements of <a href="expression.htm#vector_expression">
Vector Expression</a>
.</p>
  
<h4>Public base classes</h4>
  
<p><code>vector_expression&lt;matrix_vector_slice&lt;M&gt; &gt;</code> </p>
  
<h4>Members</h4>
  
<table border="1">
     <tbody>
    <tr>
         <th>Member </th>
         <th>Description </th>
     </tr>
     <tr>
         <td><code>matrix_vector_slice (matrix_type &amp;data, <br>
         &nbsp;const slice &amp;s1, const slice &amp;s2)</code></td>
         <td>Constructs a sub vector.</td>
     </tr>
     <tr>
         <td><code>size_type size () const</code></td>
         <td>Returns the size of the sub vector.</td>
     </tr>
     <tr>
         <td><code>const_reference operator () (size_type i) const</code></td>
         <td>Returns the value of the <code>i</code>-th element. </td>
     </tr>
     <tr>
         <td><code>reference operator () (size_type i)</code></td>
         <td>Returns a reference of the <code>i</code>-th element.      
  </td>
     </tr>
     <tr>
         <td><code>matrix_vector_slice &amp;operator = (const         matrix_vector_slice
&amp;mvs)</code></td>
         <td>The assignment operator.</td>
     </tr>
     <tr>
         <td><code>matrix_vector_slice &amp;assign_temporary         (matrix_vector_slice
&amp;mvs)</code></td>
         <td>Assigns a temporary. May change the matrix vector         slice
      <code>vs</code>.</td>
     </tr>
     <tr>
         <td><code>template&lt;class AE&gt;<br>
         matrix_vector_slice &amp;operator = (const         vector_expression&lt;AE&gt;
&amp;ae)</code></td>
         <td>The extended assignment operator.</td>
     </tr>
     <tr>
         <td><code>template&lt;class AE&gt;<br>
         matrix_vector_slice &amp;assign (const         vector_expression&lt;AE&gt;
&amp;ae)</code></td>
         <td>Assigns a vector expression to the sub vector. Left        
and right hand side of the assignment should be         independent.</td>
     </tr>
     <tr>
         <td><code>template&lt;class AE&gt;<br>
         matrix_vector_slice &amp;operator += (const         vector_expression&lt;AE&gt;
&amp;ae)</code></td>
         <td>A computed assignment operator. Adds the vector         expression
to the sub vector.</td>
     </tr>
     <tr>
         <td><code>template&lt;class AE&gt;<br>
         matrix_vector_slice &amp;plus_assign (const         vector_expression&lt;AE&gt;
&amp;ae)</code></td>
         <td>Adds a vector expression to the sub vector. Left and       
 right hand side of the assignment should be independent.</td>
     </tr>
     <tr>
         <td><code>template&lt;class AE&gt;<br>
         matrix_vector_slice &amp;operator -= (const         vector_expression&lt;AE&gt;
&amp;ae)</code></td>
         <td>A computed assignment operator. Subtracts the vector       
 expression from the sub vector.</td>
     </tr>
     <tr>
         <td><code>template&lt;class AE&gt;<br>
         matrix_vector_slice &amp;minus_assign (const         vector_expression&lt;AE&gt;
&amp;ae)</code></td>
         <td>Subtracts a vector expression from the sub vector.         Left
and right hand side of the assignment should be         independent.</td>
     </tr>
     <tr>
         <td><code>template&lt;class AT&gt;<br>
         matrix_vector_slice &amp;operator *= (const AT &amp;at)</code></td>
         <td>A computed assignment operator. Multiplies the sub         vector
with a scalar.</td>
     </tr>
     <tr>
         <td><code>template&lt;class AT&gt;<br>
         matrix_vector_slice &amp;operator /= (const AT &amp;at)</code></td>
         <td>A computed assignment operator. Divides the sub         vector
through a scalar.</td>
     </tr>
     <tr>
         <td><code>void swap (matrix_vector_slice &amp;mvs)</code></td>
         <td>Swaps the contents of the sub vectors. </td>
     </tr>
     <tr>
         <td><code>const_iterator begin () const</code></td>
         <td>Returns a <code>const_iterator</code> pointing to the      
  beginning of the <code>matrix_vector_slice</code>. </td>
     </tr>
     <tr>
         <td><code>const_iterator end () const</code></td>
         <td>Returns a <code>const_iterator</code> pointing to the      
  end of the <code>matrix_vector_slice</code>. </td>
     </tr>
     <tr>
         <td><code>iterator begin () </code></td>
         <td>Returns a <code>iterator</code> pointing to the         beginning
of the <code>matrix_vector_slice</code>. </td>
     </tr>
     <tr>
         <td><code>iterator end () </code></td>
         <td>Returns a <code>iterator</code> pointing to the end        
of the <code>matrix_vector_slice</code>. </td>
     </tr>
     <tr>
         <td><code>const_reverse_iterator rbegin () const</code></td>
         <td>Returns a <code>const_reverse_iterator</code>         pointing
to the beginning of the reversed <code>matrix_vector_slice</code>.      
  </td>
     </tr>
     <tr>
         <td><code>const_reverse_iterator rend () const</code></td>
         <td>Returns a <code>const_reverse_iterator</code>         pointing
to the end of the reversed <code>matrix_vector_slice</code>.         </td>
     </tr>
     <tr>
         <td><code>reverse_iterator rbegin () </code></td>
         <td>Returns a <code>reverse_iterator</code> pointing to        
the beginning of the reversed <code>matrix_vector_slice</code>.         </td>
     </tr>
     <tr>
         <td><code>reverse_iterator rend () </code></td>
         <td>Returns a <code>reverse_iterator</code> pointing to        
the end of the reversed <code>matrix_vector_slice</code>.         </td>
     </tr>
 
  </tbody>
</table>
  
<h4>Interface</h4>
  
<pre><code>    // Matrix based vector slice class<br>    template&lt;class M&gt;<br>    class matrix_vector_slice:<br>        public vector_expression&lt;matrix_vector_slice&lt;M&gt; &gt; {<br>    public:      <br>        typedef const M const_matrix_type;<br>        typedef M matrix_type;<br>        typedef typename M::size_type size_type;<br>        typedef typename M::difference_type difference_type;<br>        typedef typename M::value_type value_type;<br>        typedef typename M::const_reference const_reference;<br>        typedef typename M::reference reference;<br>        typedef typename M::const_pointer const_pointer;<br>        typedef typename M::pointer pointer;<br>        typedef const vector_const_reference&lt;const matrix_vector_slice&lt;matrix_type&gt; &gt; const_closure_type;<br>        typedef vector_reference&lt;matrix_vector_slice&lt;matrix_type&gt; &gt; closure_type;<br>        typedef slice::const_iterator const_iterator1_type;<br>        typedef slice::const_iterator iterator1_type;<br>        typedef slice::const_iterator const_iterator2_type;<br>        typedef slice::const_iterator iterator2_type;<br>        typedef typename storage_restrict_traits&lt;typename M::storage_category,<br>                                                 dense_proxy_tag&gt;::storage_category storage_category;<br><br>        // Construction and destruction<br>        matrix_vector_slice ();<br>        matrix_vector_slice (matrix_type &amp;data, const slice &amp;s1, const slice &amp;s2);<br><br>        // Accessors<br>        size_type size () const;<br>        const_matrix_type &amp;data () const;<br>        matrix_type &amp;data ();<br><br><br>        // Element access<br>        const_reference operator () (size_type i) const;<br>        reference operator () (size_type i);<br><br>        const_reference operator [] (size_type i) const;<br>        reference operator [] (size_type i);<br><br>        // Assignment<br>        matrix_vector_slice &amp;operator = (const matrix_vector_slice &amp;mvs);<br>        matrix_vector_slice &amp;assign_temporary (matrix_vector_slice &amp;mvs);<br>        template&lt;class AE&gt;<br>        matrix_vector_slice &amp;operator = (const vector_expression&lt;AE&gt; &amp;ae);<br>        template&lt;class AE&gt;<br>        matrix_vector_slice &amp;assign (const vector_expression&lt;AE&gt; &amp;ae);<br>        template&lt;class AE&gt;<br>        matrix_vector_slice &amp;operator += (const vector_expression&lt;AE&gt; &amp;ae);<br>        template&lt;class AE&gt;<br>        matrix_vector_slice &amp;plus_assign (const vector_expression&lt;AE&gt; &amp;ae);<br>        template&lt;class AE&gt;<br>        matrix_vector_slice &amp;operator -= (const vector_expression&lt;AE&gt; &amp;ae);<br>        template&lt;class AE&gt;<br>        matrix_vector_slice &amp;minus_assign (const vector_expression&lt;AE&gt; &amp;ae);<br>        template&lt;class AT&gt;<br>        matrix_vector_slice &amp;operator *= (const AT &amp;at);<br>        template&lt;class AT&gt;<br>        matrix_vector_slice &amp;operator /= (const AT &amp;at);<br><br>        // Swapping<br>        void swap (matrix_vector_slice &amp;mvs);<br>        friend void swap (matrix_vector_slice &amp;mvs1, matrix_vector_slice &amp;mvs2);<br><br>        class const_iterator;<br>        class iterator;<br><br>        // Element lookup<br>        const_iterator find_first (size_type i) const;<br>        iterator find_first (size_type i);<br>        const_iterator find_last (size_type i) const;<br>        iterator find_last (size_type i);<br><br>        // Iterators simply are indices.<br><br>        class const_iterator:<br>            public container_const_reference&lt;matrix_vector_slice&gt;,<br>            public random_access_iterator_base&lt;const_iterator, value_type&gt; {<br>        public:<br>            typedef typename restrict_traits&lt;typename M::const_iterator1::iterator_category,<br>                                             typename M::const_iterator2::iterator_category&gt;::iterator_category iterator_category; <br>            typedef typename matrix_vector_slice::difference_type difference_type;<br>            typedef typename matrix_vector_slice::value_type value_type;<br>            typedef typename matrix_vector_slice::const_reference reference;<br>            typedef typename matrix_vector_slice::const_pointer pointer;<br><br>            // Construction and destruction<br>            const_iterator ();<br>            const_iterator (const matrix_vector_slice &amp;mvs, const const_iterator1_type &amp;it1, const const_iterator2_type &amp;it2);<br>            const_iterator (const iterator &amp;it);<br><br>            // Arithmetic<br>            const_iterator &amp;operator ++ ();<br>            const_iterator &amp;operator -- ();<br>            const_iterator &amp;operator += (difference_type n);<br>            const_iterator &amp;operator -= (difference_type n);<br>            difference_type operator - (const const_iterator &amp;it) const;<br><br>            // Dereference<br>            reference operator * () const;<br><br>            // Index<br>            size_type  index () const;<br><br>            // Assignment <br>            const_iterator &amp;operator = (const const_iterator &amp;it);<br><br>            // Comparison<br>            bool operator == (const const_iterator &amp;it) const;<br>            bool operator &lt;(const const_iterator &amp;it) const;<br>        };<br><br>        const_iterator begin () const;<br>        const_iterator end () const;<br><br>        class iterator:<br>            public container_reference&lt;matrix_vector_slice&gt;,<br>            public random_access_iterator_base&lt;iterator, value_type&gt; {<br>        public:<br>            typedef typename restrict_traits&lt;typename M::iterator1::iterator_category,<br>                                             typename M::iterator2::iterator_category&gt;::iterator_category iterator_category; <br>            typedef typename matrix_vector_slice::difference_type difference_type;<br>            typedef typename matrix_vector_slice::value_type value_type;<br>            typedef typename matrix_vector_slice::reference reference;<br>            typedef typename matrix_vector_slice::pointer pointer;<br><br>            // Construction and destruction<br>            iterator ();<br>            iterator (matrix_vector_slice &amp;mvs, const iterator1_type &amp;it1, const iterator2_type &amp;it2);<br><br>            // Arithmetic<br>            iterator &amp;operator ++ ();<br>            iterator &amp;operator -- ();<br>            iterator &amp;operator += (difference_type n);<br>            iterator &amp;operator -= (difference_type n);<br>            difference_type operator - (const iterator &amp;it) const;<br><br>            // Dereference<br>            reference operator * () const;<br><br>            // Index<br>            size_type index () const;<br><br>            // Assignment <br>            iterator &amp;operator = (const iterator &amp;it);<br><br>            // Comparison<br>            bool operator == (const iterator &amp;it) const;<br>            bool operator &lt;(const iterator &amp;it) const;<br>        };<br><br>        iterator begin ();<br>        iterator end ();<br><br>        // Reverse iterator<br><br>        typedef reverse_iterator_base&lt;const_iterator&gt; const_reverse_iterator;<br><br>        const_reverse_iterator rbegin () const;<br>        const_reverse_iterator rend () const;<br><br>        typedef reverse_iterator_base&lt;iterator&gt; reverse_iterator;<br><br>        reverse_iterator rbegin ();<br>        reverse_iterator rend ();<br>    };</code></pre>
  
<h2><a name="matrix_range"></a>
Matrix Range</h2>
  
<h4>Description</h4>
  
<p>The templated class <code>matrix_range&lt;M&gt; </code>allows addressing
a sub matrix of a matrix.</p>
  
<h4>Example</h4>
  
<pre>#include &lt;boost/numeric/ublas/matrix.hpp&gt;<br>#include &lt;boost/numeric/ublas/io.hpp&gt;<br><br>int main () {<br>    using namespace boost::numeric::ublas;<br>    matrix&lt;double&gt; m (3, 3);<br>    matrix_range&lt;matrix&lt;double&gt; &gt; mr (m, range (0, 3), range (0, 3));<br>    for (unsigned i = 0; i &lt; mr.size1 (); ++ i)<br>        for (unsigned j = 0; j &lt; mr.size2 (); ++ j)<br>            mr (i, j) = 3 * i + j;<br>    std::cout &lt;&lt; mr &lt;&lt; std::endl;<br>}<br></pre>
<h4>Definition</h4>
  
<p>Defined in the header matrix_proxy.hpp.</p>
  
<h4>Template parameters</h4>
  
<table border="1">
     <tbody>
    <tr>
         <th>Parameter </th>
         <th>Description </th>
         <th>Default </th>
     </tr>
     <tr>
         <td><code>M</code> </td>
         <td>The type of matrix referenced.</td>
         <td>&nbsp;</td>
     </tr>
 
  </tbody>
</table>
  
<h4>Model of</h4>
  
<p><a href="expression.htm#matrix_expression">Matrix Expression</a>
. </p>
  
<h4>Type requirements</h4>
  
<p>None, except for those imposed by the requirements of <a href="expression.htm#matrix_expression">
Matrix Expression</a>
.</p>
  
<h4>Public base classes</h4>
  
<p><code>matrix_expression&lt;matrix_range&lt;M&gt; &gt;</code> </p>
  
<h4>Members</h4>
  
<table border="1">
     <tbody>
    <tr>
         <th>Member </th>
         <th>Description </th>
     </tr>
     <tr>
         <td><code>matrix_range (matrix_type &amp;data,<br>
         &nbsp;const range &amp;r1, const range &amp;r2)</code></td>
         <td>Constructs a sub matrix.</td>
     </tr>
     <tr>
         <td><code>size_type start1 () const</code></td>
         <td>Returns the index of the first row.</td>
     </tr>
     <tr>
         <td><code>size_type size1 () const</code></td>
         <td>Returns the number of rows. </td>
     </tr>
     <tr>
         <td><code>size_type start2 () const</code></td>
         <td>Returns the index of the first column.</td>
     </tr>
     <tr>
         <td><code>size_type size2 () const</code></td>
         <td>Returns the number of columns. </td>
     </tr>
     <tr>
         <td><code>const_reference operator () (size_type i,         size_type
j) const</code></td>
         <td>Returns the value of the <code>j</code>-th element in      
  the<code> i</code>-th row. </td>
     </tr>
     <tr>
         <td><code>reference operator () (size_type i, size_type        
j)</code></td>
         <td>Returns a reference of the <code>j</code>-th element       
 in the<code> i</code>-th row. </td>
     </tr>
     <tr>
         <td><code>matrix_range &amp;operator = (const         matrix_range
&amp;mr)</code></td>
         <td>The assignment operator.</td>
     </tr>
     <tr>
         <td><code>matrix_range &amp;assign_temporary         (matrix_range
&amp;mr)</code></td>
         <td>Assigns a temporary. May change the matrix range <code>mr</code>
.</td>
     </tr>
     <tr>
         <td><code>template&lt;class AE&gt;<br>
         matrix_range &amp;operator = (const         matrix_expression&lt;AE&gt;
&amp;ae)</code></td>
         <td>The extended assignment operator.</td>
     </tr>
     <tr>
         <td><code>template&lt;class AE&gt;<br>
         matrix_range &amp;assign (const         matrix_expression&lt;AE&gt;
&amp;ae)</code></td>
         <td>Assigns a matrix expression to the sub matrix. Left        
and right hand side of the assignment should be         independent.</td>
     </tr>
     <tr>
         <td><code>template&lt;class AE&gt;<br>
         matrix_range &amp;operator += (const         matrix_expression&lt;AE&gt;
&amp;ae)</code></td>
         <td>A computed assignment operator. Adds the matrix         expression
to the sub matrix.</td>
     </tr>
     <tr>
         <td><code>template&lt;class AE&gt;<br>
         matrix_range &amp;plus_assign (const         matrix_expression&lt;AE&gt;
&amp;ae)</code></td>
         <td>Adds a matrix expression to the sub matrix. Left and       
 right hand side of the assignment should be independent.</td>
     </tr>
     <tr>
         <td><code>template&lt;class AE&gt;<br>
         matrix_range &amp;operator -= (const         matrix_expression&lt;AE&gt;
&amp;ae)</code></td>
         <td>A computed assignment operator. Subtracts the matrix       
 expression from the sub matrix.</td>
     </tr>
     <tr>
         <td><code>template&lt;class AE&gt;<br>
         matrix_range &amp;minus_assign (const         matrix_expression&lt;AE&gt;
&amp;ae)</code></td>
         <td>Subtracts a matrix expression from the sub matrix.         Left
and right hand side of the assignment should be         independent.</td>
     </tr>
     <tr>
         <td><code>template&lt;class AT&gt;<br>
         matrix_range &amp;operator *= (const AT &amp;at)</code></td>
         <td>A computed assignment operator. Multiplies the sub         matrix
with a scalar.</td>
     </tr>
     <tr>
         <td><code>template&lt;class AT&gt;<br>
         matrix_range &amp;operator /= (const AT &amp;at)</code></td>
         <td>A computed assignment operator. Divides the sub         matrix
through a scalar.</td>
     </tr>
     <tr>
         <td><code>void swap (matrix_range &amp;mr)</code></td>
         <td>Swaps the contents of the sub matrices. </td>
     </tr>
     <tr>
         <td><code>const_iterator1 begin1 () const</code></td>
         <td>Returns a <code>const_iterator1</code> pointing to         the
beginning of the <code>matrix_range</code>. </td>
     </tr>
     <tr>
         <td><code>const_iterator1 end1 () const</code></td>
         <td>Returns a <code>const_iterator1</code> pointing to         the
end of the <code>matrix_range</code>. </td>
     </tr>
     <tr>
         <td><code>iterator1 begin1 () </code></td>
         <td>Returns a <code>iterator1</code> pointing to the         beginning
of the <code>matrix_range</code>. </td>
     </tr>
     <tr>
         <td><code>iterator1 end1 () </code></td>
         <td>Returns a <code>iterator1</code> pointing to the end       
 of the <code>matrix_range</code>. </td>
     </tr>
     <tr>
         <td><code>const_iterator2 begin2 () const</code></td>
         <td>Returns a <code>const_iterator2</code> pointing to         the
beginning of the <code>matrix_range</code>. </td>
     </tr>
     <tr>
         <td><code>const_iterator2 end2 () const</code></td>
         <td>Returns a <code>const_iterator2</code> pointing to         the
end of the <code>matrix_range</code>. </td>
     </tr>
     <tr>
         <td><code>iterator2 begin2 () </code></td>
         <td>Returns a <code>iterator2</code> pointing to the         beginning
of the <code>matrix_range</code>. </td>
     </tr>
     <tr>
         <td><code>iterator2 end2 () </code></td>
         <td>Returns a <code>iterator2</code> pointing to the end       
 of the <code>matrix_range</code>. </td>
     </tr>
     <tr>
         <td><code>const_reverse_iterator1 rbegin1 () const</code></td>
         <td>Returns a <code>const_reverse_iterator1</code>         pointing
to the beginning of the reversed <code>matrix_range</code>.         </td>
     </tr>
     <tr>
         <td><code>const_reverse_iterator1 rend1 () const</code></td>
         <td>Returns a <code>const_reverse_iterator1</code>         pointing
to the end of the reversed <code>matrix_range</code>.         </td>
     </tr>
     <tr>
         <td><code>reverse_iterator1 rbegin1 () </code></td>
         <td>Returns a <code>reverse_iterator1</code> pointing to       
 the beginning of the reversed <code>matrix_range</code>. </td>
     </tr>
     <tr>
         <td><code>reverse_iterator1 rend1 () </code></td>
         <td>Returns a <code>reverse_iterator1</code> pointing to       
 the end of the reversed <code>matrix_range</code>. </td>
     </tr>
     <tr>
         <td><code>const_reverse_iterator2 rbegin2 () const</code></td>
         <td>Returns a <code>const_reverse_iterator2</code>         pointing
to the beginning of the reversed <code>matrix_range</code>.         </td>
     </tr>
     <tr>
         <td><code>const_reverse_iterator2 rend2 () const</code></td>
         <td>Returns a <code>const_reverse_iterator2</code>         pointing
to the end of the reversed <code>matrix_range</code>.         </td>
     </tr>
     <tr>
         <td><code>reverse_iterator2 rbegin2 () </code></td>
         <td>Returns a <code>reverse_iterator2</code> pointing to       
 the beginning of the reversed <code>matrix_range</code>. </td>
     </tr>
     <tr>
         <td><code>reverse_iterator2 rend2 () </code></td>
         <td>Returns a <code>reverse_iterator2</code> pointing to       
 the end of reversed the <code>matrix_range</code>. </td>
     </tr>
 
  </tbody>
</table>
  
<h4>Interface</h4>
  
<pre><code>    // Matrix based range class<br>    template&lt;class M&gt;<br>    class matrix_range:<br>        public matrix_expression&lt;matrix_range&lt;M&gt; &gt; {<br>    public:      <br>        typedef const M const_matrix_type;<br>        typedef M matrix_type;<br>        typedef typename M::size_type size_type;<br>        typedef typename M::difference_type difference_type;<br>        typedef typename M::value_type value_type;<br>        typedef typename M::const_reference const_reference;<br>        typedef typename M::reference reference;<br>        typedef typename M::const_pointer const_pointer;<br>        typedef typename M::pointer pointer;<br>        typedef const matrix_const_reference&lt;const matrix_range&lt;matrix_type&gt; &gt; const_closure_type;<br>        typedef matrix_reference&lt;matrix_range&lt;matrix_type&gt; &gt; closure_type;<br>        typedef typename M::const_iterator1 const_iterator1_type;<br>        typedef typename M::iterator1 iterator1_type;<br>        typedef typename M::const_iterator2 const_iterator2_type;<br>        typedef typename M::iterator2 iterator2_type;<br>        typedef typename storage_restrict_traits&lt;typename M::storage_category,<br>                                                 dense_proxy_tag&gt;::storage_category storage_category;<br>        typedef typename M::orientation_category orientation_category;<br><br>        // Construction and destruction<br>        matrix_range ();<br>        matrix_range (matrix_type &amp;data, const range &amp;r1, const range &amp;r2);<br><br>        // Accessors<br>        size_type start1 () const;<br>        size_type size1 () const;<br>        size_type start2() const;<br>        size_type size2 () const;<br>        const_matrix_type &amp;data () const;<br>        matrix_type &amp;data ();<br><br><br>        // Element access<br>        const_reference operator () (size_type i, size_type j) const;<br>        reference operator () (size_type i, size_type j);<br><br>        matrix_range&lt;matrix_type&gt; project (const range &amp;r1, const range &amp;r2) const;<br><br>        // Assignment<br>        matrix_range &amp;operator = (const matrix_range &amp;mr);<br>        matrix_range &amp;assign_temporary (matrix_range &amp;mr);<br>        template&lt;class AE&gt;<br>        matrix_range &amp;operator = (const matrix_expression&lt;AE&gt; &amp;ae);<br>        template&lt;class AE&gt;<br>        matrix_range &amp;assign (const matrix_expression&lt;AE&gt; &amp;ae);<br>        template&lt;class AE&gt;<br>        matrix_range&amp; operator += (const matrix_expression&lt;AE&gt; &amp;ae);<br>        template&lt;class AE&gt;<br>        matrix_range &amp;plus_assign (const matrix_expression&lt;AE&gt; &amp;ae);<br>        template&lt;class AE&gt;<br>        matrix_range&amp; operator -= (const matrix_expression&lt;AE&gt; &amp;ae);<br>        template&lt;class AE&gt;<br>        matrix_range &amp;minus_assign (const matrix_expression&lt;AE&gt; &amp;ae);<br>        template&lt;class AT&gt;<br>        matrix_range&amp; operator *= (const AT &amp;at);<br>        template&lt;class AT&gt;<br>        matrix_range&amp; operator /= (const AT &amp;at);<br><br>        // Swapping<br>        void swap (matrix_range &amp;mr);<br>        friend void swap (matrix_range &amp;mr1, matrix_range &amp;mr2);<br><br>        class const_iterator1;<br>        class iterator1;<br>        class const_iterator2;<br>        class iterator2;<br>        typedef reverse_iterator_base1&lt;const_iterator1&gt; const_reverse_iterator1;<br>        typedef reverse_iterator_base1&lt;iterator1&gt; reverse_iterator1;<br>        typedef reverse_iterator_base2&lt;const_iterator2&gt; const_reverse_iterator2;<br>        typedef reverse_iterator_base2&lt;iterator2&gt; reverse_iterator2;<br><br>        // Element lookup<br>        const_iterator1 find_first1 (int rank, size_type i, size_type j) const;<br>        iterator1 find_first1 (int rank, size_type i, size_type j);<br>        const_iterator1 find_last1 (int rank, size_type i, size_type j) const;<br>        iterator1 find_last1 (int rank, size_type i, size_type j);<br>        const_iterator2 find_first2 (int rank, size_type i, size_type j) const;<br>        iterator2 find_first2 (int rank, size_type i, size_type j);<br>        const_iterator2 find_last2 (int rank, size_type i, size_type j) const;<br>        iterator2 find_last2 (int rank, size_type i, size_type j);<br><br>        // Iterators simply are pointers.<br><br>        class const_iterator1:<br>            public container_const_reference&lt;matrix_range&gt;,<br>            public random_access_iterator_base&lt;const_iterator1, value_type&gt; {<br>        public:<br>            typedef typename const_iterator1_type::iterator_category iterator_category;<br>            typedef typename const_iterator1_type::difference_type difference_type;<br>            typedef typename const_iterator1_type::value_type value_type;<br>            typedef typename const_iterator1_type::reference reference;<br>            typedef typename const_iterator1_type::pointer pointer;<br>            typedef const_iterator2 dual_iterator_type;<br>            typedef const_reverse_iterator2 dual_reverse_iterator_type;<br><br>            // Construction and destruction<br>            const_iterator1 ();<br>            const_iterator1 (const matrix_range &amp;mr, const const_iterator1_type &amp;it);<br>            const_iterator1 (const iterator1 &amp;it);<br><br>            // Arithmetic<br>            const_iterator1 &amp;operator ++ ();<br>            const_iterator1 &amp;operator -- ();<br>            const_iterator1 &amp;operator += (difference_type n);<br>            const_iterator1 &amp;operator -= (difference_type n);<br>            difference_type operator - (const const_iterator1 &amp;it) const;<br><br>            // Dereference<br>            reference operator * () const;<br><br>            const_iterator2 begin () const;<br>            const_iterator2 end () const;<br>            const_reverse_iterator2 rbegin () const;<br>            const_reverse_iterator2 rend () const;<br><br>            // Indices<br>            size_type index1 () const;<br>            size_type index2 () const;<br><br>            // Assignment <br>            const_iterator1 &amp;operator = (const const_iterator1 &amp;it);<br><br>            // Comparison<br>            bool operator == (const const_iterator1 &amp;it) const;<br>            bool operator &lt;(const const_iterator1 &amp;it) const;<br>        };<br><br>        const_iterator1 begin1 () const;<br>        const_iterator1 end1 () const;<br><br>        class iterator1:<br>            public container_reference&lt;matrix_range&gt;,<br>            public random_access_iterator_base&lt;iterator1, value_type&gt; {<br>        public:<br>            typedef typename iterator1_type::iterator_category iterator_category;<br>            typedef typename iterator1_type::difference_type difference_type;<br>            typedef typename iterator1_type::value_type value_type;<br>            typedef typename iterator1_type::reference reference;<br>            typedef typename iterator1_type::pointer pointer;<br>            typedef iterator2 dual_iterator_type;<br>            typedef reverse_iterator2 dual_reverse_iterator_type;<br><br>            // Construction and destruction<br>            iterator1 ();<br>            iterator1 (matrix_range &amp;mr, const iterator1_type &amp;it);<br><br>            // Arithmetic<br>            iterator1 &amp;operator ++ ();<br>            iterator1 &amp;operator -- ();<br>            iterator1 &amp;operator += (difference_type n);<br>            iterator1 &amp;operator -= (difference_type n);<br>            difference_type operator - (const iterator1 &amp;it) const;<br><br>            // Dereference<br>            reference operator * () const;<br><br>            iterator2 begin () const;<br>            iterator2 end () const;<br>            reverse_iterator2 rbegin () const;<br>            reverse_iterator2 rend () const;<br><br>            // Indices<br>            size_type index1 () const;<br>            size_type index2 () const;<br><br>            // Assignment <br>            iterator1 &amp;operator = (const iterator1 &amp;it);<br><br>            // Comparison<br>            bool operator == (const iterator1 &amp;it) const;<br>            bool operator &lt;(const iterator1 &amp;it) const;<br>        };<br><br>        iterator1 begin1 ();<br>        iterator1 end1 ();<br><br>        class const_iterator2:<br>            public container_const_reference&lt;matrix_range&gt;,<br>            public random_access_iterator_base&lt;const_iterator2, value_type&gt; {<br>        public:<br>            typedef typename const_iterator2_type::iterator_category iterator_category;<br>            typedef typename const_iterator2_type::difference_type difference_type;<br>            typedef typename const_iterator2_type::value_type value_type;<br>            typedef typename const_iterator2_type::reference reference;<br>            typedef typename const_iterator2_type::pointer pointer;<br>            typedef const_iterator1 dual_iterator_type;<br>            typedef const_reverse_iterator1 dual_reverse_iterator_type;<br><br>            // Construction and destruction<br>            const_iterator2 ();<br>            const_iterator2 (const matrix_range &amp;mr, const const_iterator2_type &amp;it);<br>            const_iterator2 (const iterator2 &amp;it);<br><br>            // Arithmetic<br>            const_iterator2 &amp;operator ++ ();<br>            const_iterator2 &amp;operator -- ();<br>            const_iterator2 &amp;operator += (difference_type n);<br>            const_iterator2 &amp;operator -= (difference_type n);<br>            difference_type operator - (const const_iterator2 &amp;it) const;<br><br>            // Dereference<br>            reference operator * () const;<br><br>            const_iterator1 begin () const;<br>            const_iterator1 end () const;<br>            const_reverse_iterator1 rbegin () const;<br>            const_reverse_iterator1 rend () const;<br><br>            // Indices<br>            size_type index1 () const;<br>            size_type index2 () const;<br><br>            // Assignment <br>            const_iterator2 &amp;operator = (const const_iterator2 &amp;it);<br><br>            // Comparison<br>            bool operator == (const const_iterator2 &amp;it) const;<br>            bool operator &lt;(const const_iterator2 &amp;it) const;<br>        };<br><br>        const_iterator2 begin2 () const;<br>        const_iterator2 end2 () const;<br><br>        class iterator2:<br>            public container_reference&lt;matrix_range&gt;,<br>            public random_access_iterator_base&lt;iterator2, value_type&gt; {<br>        public:<br>            typedef typename iterator2_type::iterator_category iterator_category;<br>            typedef typename iterator2_type::difference_type difference_type;<br>            typedef typename iterator2_type::value_type value_type;<br>            typedef typename iterator2_type::reference reference;<br>            typedef typename iterator2_type::pointer pointer;<br>            typedef iterator1 dual_iterator_type;<br>            typedef reverse_iterator1 dual_reverse_iterator_type;<br><br>            // Construction and destruction<br>            iterator2 ();<br>            iterator2 (matrix_range &amp;mr, const iterator2_type &amp;it);<br><br>            // Arithmetic<br>            iterator2 &amp;operator ++ ();<br>            iterator2 &amp;operator -- ();<br>            iterator2 &amp;operator += (difference_type n);<br>            iterator2 &amp;operator -= (difference_type n);<br>            difference_type operator - (const iterator2 &amp;it) const;<br><br>            // Dereference<br>            reference operator * () const;<br><br>            iterator1 begin () const;<br>            iterator1 end () const;<br>            reverse_iterator1 rbegin () const;<br>            reverse_iterator1 rend () const;<br><br>            // Indices<br>            size_type index1 () const;<br>            size_type index2 () const;<br><br>            // Assignment <br>            iterator2 &amp;operator = (const iterator2 &amp;it);<br><br>            // Comparison<br>            bool operator == (const iterator2 &amp;it) const;<br>            bool operator &lt;(const iterator2 &amp;it) const;<br>        };<br><br>        iterator2 begin2 ();<br>        iterator2 end2 ();<br><br>        // Reverse iterators<br><br>        const_reverse_iterator1 rbegin1 () const;<br>        const_reverse_iterator1 rend1 () const;<br><br>        reverse_iterator1 rbegin1 ();<br>        reverse_iterator1 rend1 ();<br><br>        const_reverse_iterator2 rbegin2 () const;<br>        const_reverse_iterator2 rend2 () const;<br><br>        reverse_iterator2 rbegin2 ();<br>        reverse_iterator2 rend2 ();<br>    };</code></pre>
  
<h3>Projections</h3>
  
<h4>Prototypes</h4>
  
<pre><code>    template&lt;class M&gt;<br>    matrix_range&lt;M&gt; project (M &amp;data, const range &amp;r1, const range &amp;r2);<br>    template&lt;class M&gt;<br>    const matrix_range&lt;const M&gt; project (const M &amp;data, const range &amp;r1, const range &amp;r2);<br>    template&lt;class M&gt;<br>    matrix_range&lt;M&gt; project (const matrix_range&lt;M&gt; &amp;data, const range &amp;r1, const range &amp;r2);</code></pre>
  
<h4>Description</h4>
  
<p>The free <code>project</code> functions support the construction of matrix
ranges.</p>
  
<h4>Definition</h4>
  
<p>Defined in the header matrix_proxy.hpp.</p>
  
<h4>Type requirements</h4>
  
<dir>     <li><code>M</code> is a model of <a href="expression.htm#matrix_expression">
Matrix Expression</a>
.</li>
 </dir>
  
<h4>Preconditions</h4>
  
<ul type="Disc">
     <li><code>r1.start () + r1.size () &lt;= data.size1 ()</code>     </li>
     <li><code>r2.start () + r2.size () &lt;= data.size2 ()</code>     </li>
 
</ul>
  
<h4>Complexity</h4>
  
<p>Quadratic depending from the size of the ranges.</p>
  
<h4>Examples</h4>
  
<pre>#include &lt;boost/numeric/ublas/matrix.hpp&gt;<br>#include &lt;boost/numeric/ublas/io.hpp&gt;<br><br>int main () {<br>    using namespace boost::numeric::ublas;<br>    matrix&lt;double&gt; m (3, 3);<br>    for (unsigned i = 0; i &lt; m.size1 (); ++ i)<br>        for (unsigned j = 0; j &lt; m.size2 (); ++ j)<br>            project (m, range (0, 3), range (0, 3)) (i, j) = 3 * i + j;<br>    std::cout &lt;&lt; project (m, range (0, 3), range (0, 3)) &lt;&lt; std::endl;<br>}<br></pre>
<h2><a name="matrix_slice"></a>
Matrix Slice</h2>
  
<h4>Description</h4>
  
<p>The templated class <code>matrix_slice&lt;M&gt; </code>allows addressing
a sliced sub matrix of a matrix.</p>
  
<h4>Example</h4>
  
<pre>#include &lt;boost/numeric/ublas/matrix.hpp&gt;<br>#include &lt;boost/numeric/ublas/io.hpp&gt;<br><br>int main () {<br>    using namespace boost::numeric::ublas;<br>    matrix&lt;double&gt; m (3, 3);<br>    matrix_slice&lt;matrix&lt;double&gt; &gt; ms (m, slice (0, 1, 3), slice (0, 1, 3));<br>    for (unsigned i = 0; i &lt; ms.size1 (); ++ i)<br>        for (unsigned j = 0; j &lt; ms.size2 (); ++ j)<br>            ms (i, j) = 3 * i + j;<br>    std::cout &lt;&lt; ms &lt;&lt; std::endl;<br>}<br></pre>
<h4>Definition</h4>
  
<p>Defined in the header matrix_proxy.hpp.</p>
  
<h4>Template parameters</h4>
  
<table border="1">
     <tbody>
    <tr>
         <th>Parameter </th>
         <th>Description </th>
         <th>Default </th>
     </tr>
     <tr>
         <td><code>M</code> </td>
         <td>The type of matrix referenced.</td>
         <td>&nbsp;</td>
     </tr>
 
  </tbody>
</table>
  
<h4>Model of</h4>
  
<p><a href="expression.htm#matrix_expression">Matrix Expression</a>
.</p>
  
<h4>Type requirements</h4>
  
<p>None, except for those imposed by the requirements of <a href="expression.htm#matrix_expression">
Matrix Expression</a>
.</p>
  
<h4>Public base classes</h4>
  
<p><code>matrix_expression&lt;matrix_slice&lt;M&gt; &gt;</code> </p>
  
<h4>Members</h4>
  
<table border="1">
     <tbody>
    <tr>
         <th>Member </th>
         <th>Description </th>
     </tr>
     <tr>
         <td><code>matrix_slice (matrix_type &amp;data,<br>
         &nbsp;const slice &amp;s1, const slice &amp;s2)</code></td>
         <td>Constructs a sub matrix.</td>
     </tr>
     <tr>
         <td><code>size_type size1 () const</code></td>
         <td>Returns the number of rows. </td>
     </tr>
     <tr>
         <td><code>size_type size2 () const</code></td>
         <td>Returns the number of columns. </td>
     </tr>
     <tr>
         <td><code>const_reference operator () (size_type i,         size_type
j) const</code></td>
         <td>Returns the value of the <code>j</code>-th element in      
  the<code> i</code>-th row. </td>
     </tr>
     <tr>
         <td><code>reference operator () (size_type i, size_type        
j)</code></td>
         <td>Returns a reference of the <code>j</code>-th element       
 in the<code> i</code>-th row. </td>
     </tr>
     <tr>
         <td><code>matrix_slice &amp;operator = (const         matrix_slice
&amp;ms)</code></td>
         <td>The assignment operator.</td>
     </tr>
     <tr>
         <td><code>matrix_slice &amp;assign_temporary         (matrix_slice
&amp;ms)</code></td>
         <td>Assigns a temporary. May change the matrix slice <code>ms</code>
.</td>
     </tr>
     <tr>
         <td><code>template&lt;class AE&gt;<br>
         matrix_slice &amp;operator = (const         matrix_expression&lt;AE&gt;
&amp;ae)</code></td>
         <td>The extended assignment operator.</td>
     </tr>
     <tr>
         <td><code>template&lt;class AE&gt;<br>
         matrix_slice &amp;assign (const         matrix_expression&lt;AE&gt;
&amp;ae)</code></td>
         <td>Assigns a matrix expression to the sub matrix. Left        
and right hand side of the assignment should be         independent.</td>
     </tr>
     <tr>
         <td><code>template&lt;class AE&gt;<br>
         matrix_slice &amp;operator += (const         matrix_expression&lt;AE&gt;
&amp;ae)</code></td>
         <td>A computed assignment operator. Adds the matrix         expression
to the sub matrix.</td>
     </tr>
     <tr>
         <td><code>template&lt;class AE&gt;<br>
         matrix_slice &amp;plus_assign (const         matrix_expression&lt;AE&gt;
&amp;ae)</code></td>
         <td>Adds a matrix expression to the sub matrix. Left and       
 right hand side of the assignment should be independent.</td>
     </tr>
     <tr>
         <td><code>template&lt;class AE&gt;<br>
         matrix_slice &amp;operator -= (const         matrix_expression&lt;AE&gt;
&amp;ae)</code></td>
         <td>A computed assignment operator. Subtracts the matrix       
 expression from the sub matrix.</td>
     </tr>
     <tr>
         <td><code>template&lt;class AE&gt;<br>
         matrix_slice &amp;minus_assign (const         matrix_expression&lt;AE&gt;
&amp;ae)</code></td>
         <td>Subtracts a matrix expression from the sub matrix.         Left
and right hand side of the assignment should be         independent.</td>
     </tr>
     <tr>
         <td><code>template&lt;class AT&gt;<br>
         matrix_slice &amp;operator *= (const AT &amp;at)</code></td>
         <td>A computed assignment operator. Multiplies the sub         matrix
with a scalar.</td>
     </tr>
     <tr>
         <td><code>template&lt;class AT&gt;<br>
         matrix_slice &amp;operator /= (const AT &amp;at)</code></td>
         <td>A computed assignment operator. Multiplies the sub         matrix
through a scalar.</td>
     </tr>
     <tr>
         <td><code>void swap (matrix_slice &amp;ms)</code></td>
         <td>Swaps the contents of the sub matrices. </td>
     </tr>
     <tr>
         <td><code>const_iterator1 begin1 () const</code></td>
         <td>Returns a <code>const_iterator1</code> pointing to         the
beginning of the <code>matrix_slice</code>. </td>
     </tr>
     <tr>
         <td><code>const_iterator1 end1 () const</code></td>
         <td>Returns a <code>const_iterator1</code> pointing to         the
end of the <code>matrix_slice</code>. </td>
     </tr>
     <tr>
         <td><code>iterator1 begin1 () </code></td>
         <td>Returns a <code>iterator1</code> pointing to the         beginning
of the <code>matrix_slice</code>. </td>
     </tr>
     <tr>
         <td><code>iterator1 end1 () </code></td>
         <td>Returns a <code>iterator1</code> pointing to the end       
 of the <code>matrix_slice</code>. </td>
     </tr>
     <tr>
         <td><code>const_iterator2 begin2 () const</code></td>
         <td>Returns a <code>const_iterator2</code> pointing to         the
beginning of the <code>matrix_slice</code>. </td>
     </tr>
     <tr>
         <td><code>const_iterator2 end2 () const</code></td>
         <td>Returns a <code>const_iterator2</code> pointing to         the
end of the <code>matrix_slice</code>. </td>
     </tr>
     <tr>
         <td><code>iterator2 begin2 () </code></td>
         <td>Returns a <code>iterator2</code> pointing to the         beginning
of the <code>matrix_slice</code>. </td>
     </tr>
     <tr>
         <td><code>iterator2 end2 () </code></td>
         <td>Returns a <code>iterator2</code> pointing to the end       
 of the <code>matrix_slice</code>. </td>
     </tr>
     <tr>
         <td><code>const_reverse_iterator1 rbegin1 () const</code></td>
         <td>Returns a <code>const_reverse_iterator1</code>         pointing
to the beginning of the reversed <code>matrix_slice</code>.         </td>
     </tr>
     <tr>
         <td><code>const_reverse_iterator1 rend1 () const</code></td>
         <td>Returns a <code>const_reverse_iterator1</code>         pointing
to the end of the reversed <code>matrix_slice</code>.         </td>
     </tr>
     <tr>
         <td><code>reverse_iterator1 rbegin1 () </code></td>
         <td>Returns a <code>reverse_iterator1</code> pointing to       
 the beginning of the reversed <code>matrix_slice</code>. </td>
     </tr>
     <tr>
         <td><code>reverse_iterator1 rend1 () </code></td>
         <td>Returns a <code>reverse_iterator1</code> pointing to       
 the end of the reversed <code>matrix_slice</code>. </td>
     </tr>
     <tr>
         <td><code>const_reverse_iterator2 rbegin2 () const</code></td>
         <td>Returns a <code>const_reverse_iterator2</code>         pointing
to the beginning of the reversed <code>matrix_slice</code>.         </td>
     </tr>
     <tr>
         <td><code>const_reverse_iterator2 rend2 () const</code></td>
         <td>Returns a <code>const_reverse_iterator2</code>         pointing
to the end of the reversed <code>matrix_slice</code>.         </td>
     </tr>
     <tr>
         <td><code>reverse_iterator2 rbegin2 () </code></td>
         <td>Returns a <code>reverse_iterator2</code> pointing to       
 the beginning of the reversed <code>matrix_slice</code>. </td>
     </tr>
     <tr>
         <td><code>reverse_iterator2 rend2 () </code></td>
         <td>Returns a <code>reverse_iterator2</code> pointing to       
 the end of the reversed <code>matrix_slice</code>. </td>
     </tr>
 
  </tbody>
</table>
  
<h4>Interface</h4>
  
<pre><code>    // Matrix based slice class<br>    template&lt;class M&gt;<br>    class matrix_slice:<br>        public matrix_expression&lt;matrix_slice&lt;M&gt; &gt; {<br>    public:      <br>        typedef const M const_matrix_type;<br>        typedef M matrix_type;<br>        typedef typename M::size_type size_type;<br>        typedef typename M::difference_type difference_type;<br>        typedef typename M::value_type value_type;<br>        typedef typename M::const_reference const_reference;<br>        typedef typename M::reference reference;<br>        typedef typename M::const_pointer const_pointer;<br>        typedef typename M::pointer pointer;<br>        typedef const matrix_const_reference&lt;const matrix_slice&lt;matrix_type&gt; &gt; const_closure_type;<br>        typedef matrix_reference&lt;matrix_slice&lt;matrix_type&gt; &gt; closure_type;<br>        typedef slice::const_iterator const_iterator1_type;<br>        typedef slice::const_iterator iterator1_type;<br>        typedef slice::const_iterator const_iterator2_type;<br>        typedef slice::const_iterator iterator2_type;<br>        typedef typename storage_restrict_traits&lt;typename M::storage_category,<br>                                                 dense_proxy_tag&gt;::storage_category storage_category;<br>        typedef typename M::orientation_category orientation_category;<br><br>        // Construction and destruction<br>        matrix_slice ();<br>        matrix_slice (matrix_type &amp;data, const slice &amp;s1, const slice &amp;s2);<br><br>        // Accessors<br>        size_type size1 () const;<br>        size_type size2 () const;<br>        const_matrix_type &amp;data () const;<br>        matrix_type &amp;data ();<br><br>        // Element access<br>        const_reference operator () (size_type i, size_type j) const;<br>        reference operator () (size_type i, size_type j);<br><br>        matrix_slice&lt;matrix_type&gt; project (const range &amp;r1, const range &amp;r2) const;<br>        matrix_slice&lt;matrix_type&gt; project (const slice &amp;s1, const slice &amp;s2) const;<br><br>        // Assignment<br>        matrix_slice &amp;operator = (const matrix_slice &amp;ms);<br>        matrix_slice &amp;assign_temporary (matrix_slice &amp;ms);<br>        template&lt;class AE&gt;<br>        matrix_slice &amp;operator = (const matrix_expression&lt;AE&gt; &amp;ae);<br>        template&lt;class AE&gt;<br>        matrix_slice &amp;assign (const matrix_expression&lt;AE&gt; &amp;ae);<br>        template&lt;class AE&gt;<br>        matrix_slice&amp; operator += (const matrix_expression&lt;AE&gt; &amp;ae);<br>        template&lt;class AE&gt;<br>        matrix_slice &amp;plus_assign (const matrix_expression&lt;AE&gt; &amp;ae);<br>        template&lt;class AE&gt;<br>        matrix_slice&amp; operator -= (const matrix_expression&lt;AE&gt; &amp;ae);<br>        template&lt;class AE&gt;<br>        matrix_slice &amp;minus_assign (const matrix_expression&lt;AE&gt; &amp;ae);<br>        template&lt;class AT&gt;<br>        matrix_slice&amp; operator *= (const AT &amp;at);<br>        template&lt;class AT&gt;<br>        matrix_slice&amp; operator /= (const AT &amp;at);<br><br>        // Swapping<br>        void swap (matrix_slice &amp;ms);<br>        friend void swap (matrix_slice &amp;ms1, matrix_slice &amp;ms2);<br><br>        class const_iterator1;<br>        class iterator1;<br>        class const_iterator2;<br>        class iterator2;<br>        typedef reverse_iterator_base1&lt;const_iterator1&gt; const_reverse_iterator1;<br>        typedef reverse_iterator_base1&lt;iterator1&gt; reverse_iterator1;<br>        typedef reverse_iterator_base2&lt;const_iterator2&gt; const_reverse_iterator2;<br>        typedef reverse_iterator_base2&lt;iterator2&gt; reverse_iterator2;<br><br>        // Element lookup<br>        const_iterator1 find_first1 (int rank, size_type i, size_type j) const;<br>        iterator1 find_first1 (int rank, size_type i, size_type j);<br>        const_iterator1 find_last1 (int rank, size_type i, size_type j) const;<br>        iterator1 find_last1 (int rank, size_type i, size_type j);<br>        const_iterator2 find_first2 (int rank, size_type i, size_type j) const;<br>        iterator2 find_first2 (int rank, size_type i, size_type j);<br>        const_iterator2 find_last2 (int rank, size_type i, size_type j) const;<br>        iterator2 find_last2 (int rank, size_type i, size_type j);<br><br>        // Iterators simply are indices.<br><br>        class const_iterator1:<br>            public container_const_reference&lt;matrix_slice&gt;,<br>            public random_access_iterator_base&lt;const_iterator1, value_type&gt; {<br>        public:<br>            typedef typename M::const_iterator1::iterator_category iterator_category;<br>            typedef typename M::const_iterator1::difference_type difference_type;<br>            typedef typename M::const_iterator1::value_type value_type;<br>            typedef typename M::const_iterator1::reference reference;<br>            typedef typename M::const_iterator1::pointer pointer;<br>            typedef const_iterator2 dual_iterator_type;<br>            typedef const_reverse_iterator2 dual_reverse_iterator_type;<br><br>            // Construction and destruction<br>            const_iterator1 ();<br>            const_iterator1 (const matrix_slice &amp;ms, const const_iterator1_type &amp;it1, const const_iterator2_type &amp;it2);<br>            const_iterator1 (const iterator1 &amp;it);<br><br>            // Arithmetic<br>            const_iterator1 &amp;operator ++ ();<br>            const_iterator1 &amp;operator -- ();<br>            const_iterator1 &amp;operator += (difference_type n);<br>            const_iterator1 &amp;operator -= (difference_type n);<br>            difference_type operator - (const const_iterator1 &amp;it) const;<br><br>            // Dereference<br>            reference operator * () const;<br><br>            const_iterator2 begin () const;<br>            const_iterator2 end () const;<br>            const_reverse_iterator2 rbegin () const;<br>            const_reverse_iterator2 rend () const;<br><br>            // Indices<br>            size_type index1 () const;<br>            size_type index2 () const;<br><br>            // Assignment<br>            const_iterator1 &amp;operator = (const const_iterator1 &amp;it);<br><br>            // Comparison<br>            bool operator == (const const_iterator1 &amp;it) const;<br>            bool operator &lt;(const const_iterator1 &amp;it) const;<br>        };<br><br>        const_iterator1 begin1 () const;<br>        const_iterator1 end1 () const;<br><br>        class iterator1:<br>            public container_reference&lt;matrix_slice&gt;,<br>            public random_access_iterator_base&lt;iterator1, value_type&gt; {<br>        public:<br>            typedef typename M::iterator1::iterator_category iterator_category;<br>            typedef typename M::iterator1::difference_type difference_type;<br>            typedef typename M::iterator1::value_type value_type;<br>            typedef typename M::iterator1::reference reference;<br>            typedef typename M::iterator1::pointer pointer;<br>            typedef iterator2 dual_iterator_type;<br>            typedef reverse_iterator2 dual_reverse_iterator_type;<br><br>            // Construction and destruction<br>            iterator1 ();<br>            iterator1 (matrix_slice &amp;ms, const iterator1_type &amp;it1, const iterator2_type &amp;it2);<br><br>            // Arithmetic<br>            iterator1 &amp;operator ++ ();<br>            iterator1 &amp;operator -- ();<br>            iterator1 &amp;operator += (difference_type n);<br>            iterator1 &amp;operator -= (difference_type n);<br>            difference_type operator - (const iterator1 &amp;it) const;<br><br>            // Dereference<br>            reference operator * () const;<br><br>            iterator2 begin () const;<br>            iterator2 end () const;<br>            reverse_iterator2 rbegin () const;<br>            reverse_iterator2 rend () const;<br><br>            // Indices<br>            size_type index1 () const;<br>            size_type index2 () const;<br><br>            // Assignment<br>            iterator1 &amp;operator = (const iterator1 &amp;it);<br><br>            // Comparison<br>            bool operator == (const iterator1 &amp;it) const;<br>            bool operator &lt;(const iterator1 &amp;it) const;<br>        };<br><br>        iterator1 begin1 ();<br>        iterator1 end1 ();<br><br>        class const_iterator2:<br>            public container_const_reference&lt;matrix_slice&gt;,<br>            public random_access_iterator_base&lt;const_iterator2, value_type&gt; {<br>        public:<br>            typedef typename M::const_iterator2::iterator_category iterator_category;<br>            typedef typename M::const_iterator2::difference_type difference_type;<br>            typedef typename M::const_iterator2::value_type value_type;<br>            typedef typename M::const_iterator2::reference reference;<br>            typedef typename M::const_iterator2::pointer pointer;<br>            typedef const_iterator1 dual_iterator_type;<br>            typedef const_reverse_iterator1 dual_reverse_iterator_type;<br><br>            // Construction and destruction<br>            const_iterator2 ();<br>            const_iterator2 (const matrix_slice &amp;ms, const const_iterator1_type &amp;it1, const const_iterator2_type &amp;it2);<br>            const_iterator2 (const iterator2 &amp;it);<br><br>            // Arithmetic<br>            const_iterator2 &amp;operator ++ ();<br>            const_iterator2 &amp;operator -- ();<br>            const_iterator2 &amp;operator += (difference_type n);<br>            const_iterator2 &amp;operator -= (difference_type n);<br>            difference_type operator - (const const_iterator2 &amp;it) const;<br><br>            // Dereference<br>            reference operator * () const;<br><br>            const_iterator1 begin () const;<br>            const_iterator1 end () const;<br>            const_reverse_iterator1 rbegin () const;<br>            const_reverse_iterator1 rend () const;<br><br>            // Indices<br>            size_type index1 () const;<br>            size_type index2 () const;<br><br>            // Assignment<br>            const_iterator2 &amp;operator = (const const_iterator2 &amp;it);<br><br>            // Comparison<br>            bool operator == (const const_iterator2 &amp;it) const;<br>            bool operator &lt;(const const_iterator2 &amp;it) const;<br>        };<br><br>        const_iterator2 begin2 () const;<br>        const_iterator2 end2 () const;<br><br>        class iterator2:<br>            public container_reference&lt;matrix_slice&gt;,<br>            public random_access_iterator_base&lt;iterator2, value_type&gt; {<br>        public:<br>            typedef typename M::iterator2::iterator_category iterator_category;<br>            typedef typename M::iterator2::difference_type difference_type;<br>            typedef typename M::iterator2::value_type value_type;<br>            typedef typename M::iterator2::reference reference;<br>            typedef typename M::iterator2::pointer pointer;<br>            typedef iterator1 dual_iterator_type;<br>            typedef reverse_iterator1 dual_reverse_iterator_type;<br><br>            // Construction and destruction<br>            iterator2 ();<br>            iterator2 (matrix_slice &amp;ms, const iterator1_type &amp;it1, const iterator2_type &amp;it2);<br><br>            // Arithmetic<br>            iterator2 &amp;operator ++ ();<br>            iterator2 &amp;operator -- ();<br>            iterator2 &amp;operator += (difference_type n);<br>            iterator2 &amp;operator -= (difference_type n);<br>            difference_type operator - (const iterator2 &amp;it) const;<br><br>            // Dereference<br>            reference operator * () const;<br><br>            iterator1 begin () const;<br>            iterator1 end () const;<br>            reverse_iterator1 rbegin () const;<br>            reverse_iterator1 rend () const;<br><br>            // Indices<br>            size_type index1 () const;<br>            size_type index2 () const;<br><br>            // Assignment<br>            iterator2 &amp;operator = (const iterator2 &amp;it);<br><br>            // Comparison<br>            bool operator == (const iterator2 &amp;it) const;<br>            bool operator &lt;(const iterator2 &amp;it) const;<br>        };<br><br>        iterator2 begin2 ();<br>        iterator2 end2 ();<br><br>        // Reverse iterators<br><br>        const_reverse_iterator1 rbegin1 () const;<br>        const_reverse_iterator1 rend1 () const;<br><br>        reverse_iterator1 rbegin1 ();<br>        reverse_iterator1 rend1 ();<br><br>        const_reverse_iterator2 rbegin2 () const;<br>        const_reverse_iterator2 rend2 () const;<br><br>        reverse_iterator2 rbegin2 ();<br>        reverse_iterator2 rend2 ();<br>    };</code></pre>
  
<h3>Projections</h3>
  
<h4>Prototypes</h4>
  
<pre><code>    template&lt;class M&gt;<br>    matrix_slice&lt;M&gt; project (const matrix_slice&lt;M&gt; &amp;data, const range &amp;r1, const range &amp;r2);<br>    template&lt;class M&gt;<br>    matrix_slice&lt;M&gt; project (M &amp;data, const slice &amp;s1, const slice &amp;s2);<br>    template&lt;class M&gt;<br>    const matrix_slice&lt;const M&gt; project (const M &amp;data, const slice &amp;s1, const slice &amp;s2);<br>    template&lt;class M&gt;<br>    matrix_slice&lt;M&gt; project (const matrix_slice&lt;M&gt; &amp;data, const slice &amp;s1, const slice &amp;s2);</code></pre>
  
<h4>Description</h4>
  
<p>The free <code>project</code> functions support the construction of matrix
slices.</p>
  
<h4>Definition</h4>
  
<p>Defined in the header matrix_proxy.hpp.</p>
  
<h4>Type requirements</h4>
  
<dir>     <li><code>M</code> is a model of <a href="expression.htm#matrix_expression">
Matrix Expression</a>
.</li>
 </dir>
  
<h4>Preconditions</h4>
  
<ul type="Disc">
     <li><code>s1.start () + s1.stride () * s1.size () &lt;= data.size1 ()</code>
     </li>
     <li><code>s2.start () + s2.stride () * s2.size () &lt;= data.size2 ()</code>
     </li>
 
</ul>
  
<h4>Complexity</h4>
  
<p>Quadratic depending from the size of the slices.</p>
  
<h4>Examples</h4>
  
<pre>#include &lt;boost/numeric/ublas/matrix.hpp&gt;<br>#include &lt;boost/numeric/ublas/io.hpp&gt;<br><br>int main () {<br>    using namespace boost::numeric::ublas;<br>    matrix&lt;double&gt; m (3, 3);<br>    for (unsigned i = 0; i &lt; m.size1 (); ++ i)<br>        for (unsigned j = 0; j &lt; m.size2 (); ++ j)<br>            project (m, slice (0, 1, 3), slice (0, 1, 3)) (i, j) = 3 * i + j;<br>    std::cout &lt;&lt; project (m, slice (0, 1, 3), slice (0, 1, 3)) &lt;&lt; std::endl;<br>}<br></pre>
<hr>  
<p>Copyright (&copy;) 2000-2002 Joerg Walter, Mathias Koch <br>
 Permission to copy, use, modify, sell and distribute this document is granted
provided this copyright notice appears in all copies. This document is provided
``as is'' without express or implied warranty, and with no claim as to its
suitability for any purpose.</p>
  
<p>Last revised: 1/15/2003</p>
 
</body>
</html>
