<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=iso-8859-1">
<meta name="Template"
content="C:\PROGRAM FILES\MICROSOFT OFFICE\OFFICE\html.dot">
<meta name="GENERATOR" content="Microsoft FrontPage Express 2.0">
<title>Regex++, RegEx Class Reference</title>
</head>

<body bgcolor="#FFFFFF" link="#0000FF" vlink="#800080">

<p>&nbsp; </p>

<table border="0" cellpadding="7" cellspacing="0" width="100%">
    <tr>
        <td valign="top"><h3><img src="../../c++boost.gif"
        alt="C++ Boost" width="276" height="86"></h3>
        </td>
        <td valign="top"><h3 align="center">Regex++, RegEx Class
        Reference. </h3>
        <p align="left"><i>Copyright (c) 1998-2001 </i></p>
        <p align="left"><i>Dr John Maddock</i></p>
        <p align="left"><i>Permission to use, copy, modify,
        distribute and sell this software and its documentation
        for any purpose is hereby granted without fee, provided
        that the above copyright notice appear in all copies and
        that both that copyright notice and this permission
        notice appear in supporting documentation. Dr John
        Maddock makes no representations about the suitability of
        this software for any purpose. It is provided &quot;as is&quot;
        without express or implied warranty.</i></p>
        </td>
    </tr>
</table>

<hr>

<h3><a name="RegEx"></a><i>Class RegEx</i></h3>

<p>#include &lt;boost/cregex.hpp&gt; </p>

<p>The class RegEx provides a high level simplified interface to
the regular expression library, this class only handles narrow
character strings, and regular expressions always follow the
&quot;normal&quot; syntax - that is the same as the standard
POSIX extended syntax, but with locale specific collation
disabled, and escape characters inside character set declarations
are allowed. </p>

<pre><b>typedef</b> <b>bool</b> (*GrepCallback)(<b>const</b> RegEx&amp; expression);
<b>typedef</b> <b>bool</b> (*GrepFileCallback)(<b>const</b> <b>char</b>* file, <b>const</b> RegEx&amp; expression);
<b>typedef</b> <b>bool</b> (*FindFilesCallback)(<b>const</b> <b>char</b>* file);

<b>class</b>&nbsp; RegEx
{
<b>public</b>:
&nbsp;&nbsp; RegEx();
&nbsp;&nbsp; RegEx(<b>const</b> RegEx&amp; o);
&nbsp;&nbsp; ~RegEx();
&nbsp;&nbsp; RegEx(<b>const</b> <b>char</b>* c, <b>bool</b> icase = <b>false</b>);
&nbsp;&nbsp; <strong>explicit</strong> RegEx(<b>const</b> std::string&amp; s, <b>bool</b> icase = <b>false</b>);
&nbsp;&nbsp; RegEx&amp; <b>operator</b>=(<b>const</b> RegEx&amp; o);
&nbsp;&nbsp; RegEx&amp; <b>operator</b>=(<b>const</b> <b>char</b>* p);
&nbsp;&nbsp; RegEx&amp; <b>operator</b>=(<b>const</b> std::string&amp; s);
&nbsp;&nbsp; <b>unsigned</b> <b>int</b> SetExpression(<b>const</b> <b>char</b>* p, <b>bool</b> icase = <b>false</b>);
&nbsp;&nbsp; <b>unsigned</b> <b>int</b> SetExpression(<b>const</b> std::string&amp; s, <b>bool</b> icase = <b>false</b>);
&nbsp;&nbsp; std::string Expression()<b>const</b>;
&nbsp;&nbsp; <font color="#000080"><i>//
 </i>&nbsp;&nbsp;<i>// now matching operators: </i>
&nbsp;&nbsp; <i>// </i></font>
&nbsp;&nbsp; <b>bool</b> Match(<b>const</b> <b>char</b>* p, <b>unsigned</b> <b>int</b> flags = match_default);
&nbsp;&nbsp; <b>bool</b> Match(<b>const</b> std::string&amp; s, <b>unsigned</b> <b>int</b> flags = match_default); 
&nbsp;&nbsp; <b>bool</b> Search(<b>const</b> <b>char</b>* p, <b>unsigned</b> <b>int</b> flags = match_default); 
&nbsp;&nbsp; <b>bool</b> Search(<b>const</b> std::string&amp; s, <b>unsigned</b> <b>int</b> flags = match_default); 
&nbsp;&nbsp; <b>unsigned</b> <b>int</b> Grep(GrepCallback cb, <b>const</b> <b>char</b>* p, <b>unsigned</b> <b>int</b> flags = match_default); 
&nbsp;&nbsp; <b>unsigned</b> <b>int</b> Grep(GrepCallback cb, <b>const</b> std::string&amp; s, <b>unsigned</b> <b>int</b> flags = match_default); 
&nbsp;&nbsp; <b>unsigned</b> <b>int</b> Grep(std::vector&lt;std::string&gt;&amp; v, <b>const</b> <b>char</b>* p, <b>unsigned</b> <b>int</b> flags = match_default); 
&nbsp;&nbsp; <b>unsigned</b> <b>int</b> Grep(std::vector&lt;std::string&gt;&amp; v, <b>const</b> std::string&amp; s, <b>unsigned</b> <b>int</b> flags = match_default); 
&nbsp;&nbsp; <b>unsigned</b> <b>int</b> Grep(std::vector&lt;<b>unsigned</b> <b>int</b>&gt;&amp; v, <b>const</b> <b>char</b>* p, <b>unsigned</b> <b>int</b> flags = match_default); 
&nbsp;&nbsp; <b>unsigned</b> <b>int</b> Grep(std::vector&lt;<b>unsigned</b> <b>int</b>&gt;&amp; v, <b>const</b> std::string&amp; s, <b>unsigned</b> <b>int</b> flags = match_default); 
&nbsp;&nbsp; <b>unsigned</b> <b>int</b> GrepFiles(GrepFileCallback cb, <b>const</b> <b>char</b>* files, <b>bool</b> recurse = <b>false</b>, <b>unsigned</b> <b>int</b> flags = match_default); 
&nbsp;&nbsp; <b>unsigned</b> <b>int</b> GrepFiles(GrepFileCallback cb, <b>const</b> std::string&amp; files, <b>bool</b> recurse = <b>false</b>, <b>unsigned</b> <b>int</b> flags = match_default); 
&nbsp;&nbsp; <b>unsigned</b> <b>int</b> FindFiles(FindFilesCallback cb, <b>const</b> <b>char</b>* files, <b>bool</b> recurse = <b>false</b>, <b>unsigned</b> <b>int</b> flags = match_default); 
&nbsp;&nbsp; <b>unsigned</b> <b>int</b> FindFiles(FindFilesCallback cb, <b>const</b> std::string&amp; files, <b>bool</b> recurse = <b>false</b>, <b>unsigned</b> <b>int</b> flags = match_default); 
&nbsp;&nbsp; std::string Merge(<b>const</b> std::string&amp; in, <b>const</b> std::string&amp; fmt, <b>bool</b> copy = <b>true</b>, <b>unsigned</b> <b>int</b> flags = match_default); 
&nbsp;&nbsp; std::string Merge(<b>const</b> char* in, <b>const</b> char* fmt, <b>bool</b> copy = <b>true</b>, <b>unsigned int </b>flags = match_default); 
&nbsp;&nbsp; <b>unsigned</b> Split(std::vector&lt;std::string&gt;&amp; v, std::string&amp; s, <b>unsigned</b> flags = match_default, <b>unsigned</b> max_count = ~0); 
&nbsp;&nbsp; <font color="#000080"><i>// 
</i>&nbsp;&nbsp; <i>// now operators for returning what matched in more detail: 
</i>&nbsp;&nbsp; <i>// 
</i></font>&nbsp;&nbsp; <b>unsigned</b> <b>int</b> Position(<b>int</b> i = 0)<b>const</b>; 
&nbsp;&nbsp; <b>unsigned</b> <b>int</b> Length(<b>int</b> i = 0)<b>const</b>; 
   <strong>bool</strong> Matched(<strong>int</strong> i = 0)<strong>const</strong>;
&nbsp;&nbsp; <b>unsigned</b> <b>int</b> Line()<b>const</b>; 
&nbsp;&nbsp; <b>unsigned int</b> Marks() const; 
&nbsp;&nbsp; std::string What(<b>int</b> i)<b>const</b>; 
&nbsp;&nbsp; std::string <b>operator</b>[](<b>int</b> i)<b>const</b> ; 

   <strong>static const unsigned int</strong> npos;
}; &nbsp; &nbsp; </pre>

<p>Member functions for class RegEx are defined as follows: <br>
&nbsp; </p>

<table border="0" cellpadding="7" cellspacing="0" width="100%">
    <tr>
        <td valign="top" width="7%">&nbsp;</td>
        <td valign="top" width="43%">RegEx();</td>
        <td valign="top" width="42%">Default constructor,
        constructs an instance of RegEx without any valid
        expression.</td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="7%">&nbsp;</td>
        <td valign="top" width="43%">RegEx(<b>const</b>
        RegEx&amp; o);</td>
        <td valign="top" width="42%">Copy constructor, all the
        properties of parameter <i>o</i> are copied.</td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="7%">&nbsp;</td>
        <td valign="top" width="43%">RegEx(<b>const</b> <b>char</b>*
        c, <b>bool</b> icase = <b>false</b>);</td>
        <td valign="top" width="42%">Constructs an instance of
        RegEx, setting the expression to <i>c</i>, if <i>icase</i>
        is <i>true</i> then matching is insensitive to case,
        otherwise it is sensitive to case. Throws <i>bad_expression</i>
        on failure.</td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="7%">&nbsp;</td>
        <td valign="top" width="43%">RegEx(<b>const</b> std::string&amp;
        s, <b>bool</b> icase = <b>false</b>);</td>
        <td valign="top" width="42%">Constructs an instance of
        RegEx, setting the expression to <i>s</i>, if <i>icase </i>is
        <i>true</i> then matching is insensitive to case,
        otherwise it is sensitive to case. Throws <i>bad_expression</i>
        on failure.</td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="7%">&nbsp;</td>
        <td valign="top" width="43%">RegEx&amp; <b>operator</b>=(<b>const</b>
        RegEx&amp; o);</td>
        <td valign="top" width="42%">Default assignment operator.</td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="7%">&nbsp;</td>
        <td valign="top" width="43%">RegEx&amp; <b>operator</b>=(<b>const</b>
        <b>char</b>* p);</td>
        <td valign="top" width="42%">Assignment operator,
        equivalent to calling <i>SetExpression(p, false).</i>
        Throws <i>bad_expression</i> on failure.</td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="7%">&nbsp;</td>
        <td valign="top" width="43%">RegEx&amp; <b>operator</b>=(<b>const</b>
        std::string&amp; s);</td>
        <td valign="top" width="42%">Assignment operator,
        equivalent to calling <i>SetExpression(s, false).</i>
        Throws <i>bad_expression</i> on failure.</td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="7%">&nbsp;</td>
        <td valign="top" width="43%"><b>unsigned</b> <b>int</b>
        SetExpression(<b>constchar</b>* p, <b>bool</b> icase = <b>false</b>);</td>
        <td valign="top" width="42%">Sets the current expression
        to <i>p</i>, if <i>icase</i> is <i>true</i> then matching
        is insensitive to case, otherwise it is sensitive to case.
        Throws <i>bad_expression</i> on failure.</td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="7%">&nbsp;</td>
        <td valign="top" width="43%"><b>unsigned</b> <b>int</b>
        SetExpression(<b>const</b> std::string&amp; s, <b>bool</b>
        icase = <b>false</b>);</td>
        <td valign="top" width="42%">Sets the current expression
        to <i>s</i>, if <i>icase</i> is <i>true</i> then matching
        is insensitive to case, otherwise it is sensitive to case.
        Throws <i>bad_expression</i> on failure.</td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="7%">&nbsp;</td>
        <td valign="top" width="43%">std::string Expression()<b>const</b>;</td>
        <td valign="top" width="42%">Returns a copy of the
        current regular expression.</td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="7%">&nbsp;</td>
        <td valign="top" width="43%"><b>bool</b> Match(<b>const</b>
        <b>char</b>* p, <b>unsigned</b> <b>int</b> flags =
        match_default);</td>
        <td valign="top" width="42%">Attempts to match the
        current expression against the text <i>p</i> using the
        match flags <i>flags</i> - see <a
        href="template_class_ref.htm#match_type">match flags</a>.
        Returns <i>true</i> if the expression matches the whole
        of the input string.</td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="7%">&nbsp;</td>
        <td valign="top" width="43%"><b>bool</b> Match(<b>const</b>
        std::string&amp; s, <b>unsigned</b> <b>int</b> flags =
        match_default) ;</td>
        <td valign="top" width="42%">Attempts to match the
        current expression against the text <i>s</i> using the
        match flags <i>flags</i> - see <a
        href="template_class_ref.htm#match_type">match flags</a>.
        Returns <i>true</i> if the expression matches the whole
        of the input string.</td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="7%">&nbsp;</td>
        <td valign="top" width="43%"><b>bool</b> Search(<b>const</b>
        <b>char</b>* p, <b>unsigned</b> <b>int</b> flags =
        match_default);</td>
        <td valign="top" width="42%">Attempts to find a match for
        the current expression somewhere in the text <i>p</i>
        using the match flags <i>flags </i>- see <a
        href="template_class_ref.htm#match_type">match flags</a>.
        Returns <i>true</i> if the match succeeds.</td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="7%">&nbsp;</td>
        <td valign="top" width="43%"><b>bool</b> Search(<b>const</b>
        std::string&amp; s, <b>unsigned</b> <b>int</b> flags =
        match_default) ;</td>
        <td valign="top" width="42%">Attempts to find a match for
        the current expression somewhere in the text <i>s</i>
        using the match flags <i>flags </i>- see <a
        href="template_class_ref.htm#match_type">match flags</a>.
        Returns <i>true</i> if the match succeeds.</td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="7%">&nbsp;</td>
        <td valign="top" width="43%"><b>unsigned</b> <b>int</b>
        Grep(GrepCallback cb, <b>const</b> <b>char</b>* p, <b>unsigned</b>
        <b>int</b> flags = match_default);</td>
        <td valign="top" width="42%">Finds all matches of the
        current expression in the text <i>p</i> using the match
        flags <i>flags </i>- see <a
        href="template_class_ref.htm#match_type">match flags</a>.
        For each match found calls the call-back function <i>cb</i>
        as: cb(*this); <p>If at any stage the call-back function
        returns false then the grep operation terminates,
        otherwise continues until no further matches are found.
        Returns the number of matches found.</p>
        </td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="7%">&nbsp;</td>
        <td valign="top" width="43%"><b>unsigned</b> <b>int</b>
        Grep(GrepCallback cb, <b>const</b> std::string&amp; s, <b>unsigned</b>
        <b>int</b> flags = match_default);</td>
        <td valign="top" width="42%">Finds all matches of the
        current expression in the text <i>s</i> using the match
        flags <i>flags </i>- see <a
        href="template_class_ref.htm#match_type">match flags</a>.
        For each match found calls the call-back function <i>cb</i>
        as: cb(*this); <p>If at any stage the call-back function
        returns false then the grep operation terminates,
        otherwise continues until no further matches are found.
        Returns the number of matches found. </p>
        </td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="7%">&nbsp;</td>
        <td valign="top" width="43%"><b>unsigned</b> <b>int</b>
        Grep(std::vector&lt;std::string&gt;&amp; v, <b>const</b> <b>char</b>*
        p, <b>unsigned</b> <b>int</b> flags = match_default);</td>
        <td valign="top" width="42%">Finds all matches of the
        current expression in the text <i>p</i> using the match
        flags <i>flags </i>- see <a
        href="template_class_ref.htm#match_type">match flags</a>.
        For each match pushes a copy of what matched onto <i>v</i>.
        Returns the number of matches found.</td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="7%">&nbsp;</td>
        <td valign="top" width="43%"><b>unsigned</b> <b>int</b>
        Grep(std::vector&lt;std::string&gt;&amp; v, <b>const</b>
        std::string&amp; s, <b>unsigned</b> <b>int</b> flags =
        match_default);</td>
        <td valign="top" width="42%">Finds all matches of the
        current expression in the text <i>s</i> using the match
        flags <i>flags </i>- see <a
        href="template_class_ref.htm#match_type">match flags</a>.
        For each match pushes a copy of what matched onto <i>v</i>.
        Returns the number of matches found.</td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="7%">&nbsp;</td>
        <td valign="top" width="43%"><b>unsigned</b> <b>int</b>
        Grep(std::vector&lt;<b>unsigned int</b>&gt;&amp; v, <b>const</b>
        <b>char</b>* p, <b>unsigned</b> <b>int</b> flags =
        match_default);</td>
        <td valign="top" width="42%">Finds all matches of the
        current expression in the text <i>p</i> using the match
        flags <i>flags </i>- see <a
        href="template_class_ref.htm#match_type">match flags</a>.
        For each match pushes the starting index of what matched
        onto <i>v</i>. Returns the number of matches found.</td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="7%">&nbsp;</td>
        <td valign="top" width="43%"><b>unsigned</b> <b>int</b>
        Grep(std::vector&lt;<b>unsigned int</b>&gt;&amp; v, <b>const</b>
        std::string&amp; s, <b>unsigned</b> <b>int</b> flags =
        match_default);</td>
        <td valign="top" width="42%">Finds all matches of the
        current expression in the text <i>s</i> using the match
        flags <i>flags </i>- see <a
        href="template_class_ref.htm#match_type">match flags</a>.
        For each match pushes the starting index of what matched
        onto <i>v</i>. Returns the number of matches found.</td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="7%">&nbsp;</td>
        <td valign="top" width="43%"><b>unsigned</b> <b>int</b>
        GrepFiles(GrepFileCallback cb, <b>const</b> <b>char</b>*
        files, <b>bool</b> recurse = <b>false</b>, <b>unsigned</b>
        <b>int</b> flags = match_default);</td>
        <td valign="top" width="42%">Finds all matches of the
        current expression in the files <i>files</i> using the
        match flags <i>flags </i>- see <a
        href="template_class_ref.htm#match_type">match flags</a>.
        For each match calls the call-back function cb.&nbsp; <p>If
        the call-back returns false then the algorithm returns
        without considering further matches in the current file,
        or any further files.&nbsp; </p>
        <p>The parameter <i>files</i> can include wild card
        characters '*' and '?', if the parameter <i>recurse</i>
        is true then searches sub-directories for matching file
        names.&nbsp; </p>
        <p>Returns the total number of matches found.</p>
        <p>May throw an exception derived from std::runtime_error
        if file io fails.</p>
        </td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="7%">&nbsp;</td>
        <td valign="top" width="43%"><b>unsigned</b> <b>int</b>
        GrepFiles(GrepFileCallback cb, <b>const</b> std::string&amp;
        files, <b>bool</b> recurse = <b>false</b>, <b>unsigned</b>
        <b>int</b> flags = match_default);</td>
        <td valign="top" width="42%">Finds all matches of the
        current expression in the files <i>files</i> using the
        match flags <i>flags </i>- see <a
        href="template_class_ref.htm#match_type">match flags</a>.
        For each match calls the call-back function cb.&nbsp; <p>If
        the call-back returns false then the algorithm returns
        without considering further matches in the current file,
        or any further files.&nbsp; </p>
        <p>The parameter <i>files</i> can include wild card
        characters '*' and '?', if the parameter <i>recurse</i>
        is true then searches sub-directories for matching file
        names.&nbsp; </p>
        <p>Returns the total number of matches found.</p>
        <p>May throw an exception derived from std::runtime_error
        if file io fails.</p>
        </td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="7%">&nbsp;</td>
        <td valign="top" width="43%"><b>unsigned</b> <b>int</b>
        FindFiles(FindFilesCallback cb, <b>const</b> <b>char</b>*
        files, <b>bool</b> recurse = <b>false</b>, <b>unsigned</b>
        <b>int</b> flags = match_default);</td>
        <td valign="top" width="42%">Searches <i>files</i> to
        find all those which contain at least one match of the
        current expression using the match flags <i>flags </i>-
        see <a href="template_class_ref.htm#match_type">match
        flags</a>. For each matching file calls the call-back
        function cb.&nbsp; <p>If the call-back returns false then
        the algorithm returns without considering any further
        files.&nbsp; </p>
        <p>The parameter <i>files</i> can include wild card
        characters '*' and '?', if the parameter <i>recurse</i>
        is true then searches sub-directories for matching file
        names.&nbsp; </p>
        <p>Returns the total number of files found.</p>
        <p>May throw an exception derived from std::runtime_error
        if file io fails.</p>
        </td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="7%">&nbsp;</td>
        <td valign="top" width="43%"><b>unsigned</b> <b>int</b>
        FindFiles(FindFilesCallback cb, <b>const</b> std::string&amp;
        files, <b>bool</b> recurse = <b>false</b>, <b>unsigned</b>
        <b>int</b> flags = match_default);</td>
        <td valign="top" width="42%">Searches <i>files</i> to
        find all those which contain at least one match of the
        current expression using the match flags <i>flags </i>-
        see <a href="template_class_ref.htm#match_type">match
        flags</a>. For each matching file calls the call-back
        function cb.&nbsp; <p>If the call-back returns false then
        the algorithm returns without considering any further
        files.&nbsp; </p>
        <p>The parameter <i>files</i> can include wild card
        characters '*' and '?', if the parameter <i>recurse</i>
        is true then searches sub-directories for matching file
        names.&nbsp; </p>
        <p>Returns the total number of files found.</p>
        <p>May throw an exception derived from std::runtime_error
        if file io fails.</p>
        </td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="7%">&nbsp;</td>
        <td valign="top" width="43%">std::string Merge(<b>const</b>
        std::string&amp; in, <b>const</b> std::string&amp; fmt, <b>bool</b>
        copy = <b>true</b>, <b>unsigned</b> <b>int</b> flags =
        match_default);</td>
        <td valign="top" width="42%">Performs a search and
        replace operation: searches through the string <i>in</i>
        for all occurrences of the current expression, for each
        occurrence replaces the match with the format string <i>fmt</i>.
        Uses <i>flags</i> to determine what gets matched, and how
        the format string should be treated. If <i>copy</i> is
        true then all unmatched sections of input are copied
        unchanged to output, if the flag <em>format_first_only</em>
        is set then only the first occurance of the pattern found
        is replaced. Returns the new string. See <a
        href="format_string.htm#format_string">also format string
        syntax</a>, <a href="template_class_ref.htm#match_type">match
        flags</a> and <a
        href="template_class_ref.htm#format_flags">format flags</a>.</td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="7%">&nbsp;</td>
        <td valign="top" width="43%">std::string Merge(<b>const</b>
        char* in, <b>const</b> char* fmt, <b>bool</b> copy = <b>true</b>,
        <b>unsigned int </b>flags = match_default);</td>
        <td valign="top" width="42%">Performs a search and
        replace operation: searches through the string <i>in</i>
        for all occurrences of the current expression, for each
        occurrence replaces the match with the format string <i>fmt</i>.
        Uses <i>flags</i> to determine what gets matched, and how
        the format string should be treated. If <i>copy</i> is
        true then all unmatched sections of input are copied
        unchanged to output, if the flag <em>format_first_only</em>
        is set then only the first occurance of the pattern found
        is replaced. Returns the new string. See <a
        href="format_string.htm#format_string">also format string
        syntax</a>, <a href="template_class_ref.htm#match_type">match
        flags</a> and <a
        href="template_class_ref.htm#format_flags">format flags</a>.</td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td>&nbsp;</td>
        <td valign="top"><b>unsigned</b> Split(std::vector&lt;std::string&gt;&amp;
        v, std::string&amp; s, <b>unsigned</b> flags =
        match_default, <b>unsigned</b> max_count = ~0);</td>
        <td valign="top">Splits the input string and pushes each
        one onto the vector. If the expression contains no marked
        sub-expressions, then one string is outputted for each
        section of the input that does not match the expression.
        If the expression does contain marked sub-expressions,
        then outputs one string for each marked sub-expression
        each time a match occurs. Outputs no more than <i>max_count
        </i>strings. Before returning, deletes from the input
        string <i>s</i> all of the input that has been processed
        (all of the string if <i>max_count</i> was not reached).
        Returns the number of strings pushed onto the vector.</td>
        <td>&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="7%">&nbsp;</td>
        <td valign="top" width="43%"><b>unsigned</b> <b>int</b>
        Position(<b>int</b> i = 0)<b>const</b>;</td>
        <td valign="top" width="42%">Returns the position of what
        matched sub-expression <i>i</i>. If <i>i = 0</i> then
        returns the position of the whole match. Returns RegEx::npos
        if the supplied index is invalid, or if the specified sub-expression
        did not participate in the match.</td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="7%">&nbsp;</td>
        <td valign="top" width="43%"><b>unsigned</b> <b>int</b>
        Length(<b>int</b> i = 0)<b>const</b>;</td>
        <td valign="top" width="42%">Returns the length of what
        matched sub-expression <i>i</i>. If <i>i = 0</i> then
        returns the length of the whole match. Returns RegEx::npos
        if the supplied index is invalid, or if the specified sub-expression
        did not participate in the match.</td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td>&nbsp;</td>
        <td><strong>bool</strong> Matched(<strong>int</strong> i
        = 0)<strong>const</strong>;</td>
        <td>Returns true if sub-expression <em>i</em> was
        matched, false otherwise.</td>
        <td>&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="7%">&nbsp;</td>
        <td valign="top" width="43%"><b>unsigned</b> <b>int</b>
        Line()<b>const</b>;</td>
        <td valign="top" width="42%">Returns the line on which
        the match occurred, indexes start from 1 not zero, if no
        match occurred then returns RegEx::npos.</td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="7%">&nbsp;</td>
        <td valign="top" width="43%"><b>unsigned int</b> Marks()
        const;</td>
        <td valign="top" width="42%">Returns the number of marked
        sub-expressions contained in the expression. Note that
        this includes the whole match (sub-expression zero), so
        the value returned is always &gt;= 1.</td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="7%">&nbsp;</td>
        <td valign="top" width="43%">std::string What(<b>int</b>
        i)<b>const</b>;</td>
        <td valign="top" width="42%">Returns a copy of what
        matched sub-expression <i>i</i>. If <i>i = 0</i> then
        returns a copy of the whole match. Returns a null string
        if the index is invalid or if the specified sub-expression
        did not participate in a match.</td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
    <tr>
        <td valign="top" width="7%">&nbsp;</td>
        <td valign="top" width="43%">std::string <b>operator</b>[](<b>int</b>
        i)<b>const</b> ;</td>
        <td valign="top" width="42%">Returns <i>what(i);</i> <p>Can
        be used to simplify access to sub-expression matches, and
        make usage more perl-like.</p>
        </td>
        <td valign="top" width="7%">&nbsp;</td>
    </tr>
</table>

<hr>

<p><i>Copyright </i><a href="mailto:John_Maddock@compuserve.com"><i>Dr
John Maddock</i></a><i> 1998-2000 all rights reserved.</i> </p>
</body>
</html>
