<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">

<HTML>
<HEAD>
<TITLE>Output test Stream</TITLE>
<LINK rel="stylesheet" type="text/css" href="style/btl-white.css" media="screen">
<LINK rel="stylesheet" type="text/css" href="style/btl-print.css" media="print">
<META http-equiv="Content-Language" content="en-us">
<META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
</HEAD>
<BODY>
<DIV class="centered">
  <TABLE class="body-table" cellspacing="3" >
  <TR>
  <TD id="body"> <A name='TOP'><IMG src='../../../c++boost.gif' width='277' height='86' alt="Boost logo"></A>
  <H1>Boost Test Library: output_test_stream tool</H1>
  <P class="page-toc"> <A href="index.htm">Home</A><BR>
    <A href="#Introduction">Introduction</A><BR>
    <A href="#Benifits">Benefits</A><BR>
    <A href="#Specification">Specification<BR>
    </A> <A href="#Tests">Examples and Tests</A> </P>
  <H2><A name="Introduction">Introduction</A></H2>
  <P class="1-line-indented">The class <SPAN class="new-term">output_test_stream</SPAN>
    is a simple tool for testing output operation with standard std::ostream facilities.
    The class output_test_stream comply to std::ostream interface so it can be used
    in place of any std::ostream argument. In addition it provide several methods to
    validate output content. Also it allows to match/save output content versus/into
    specified file. Working mode of the output_test_stream could be defined by framework
    parameter &quot;<A href="unit_test_framework.htm#FrameworkParameters"> Save pattern</A>&quot;</P>
  <H2><A name="Benifits">Benefits</A></H2>
  <P class="1-line-indented">Simplified mechanism for checking correctness of output
    operations. <SPAN class="ref-to-top"><A href="#TOP"><IMG src="imgs/uarrow.gif" alt="reference to the top"></A></SPAN></P>
  <H2><A name="Specification">Specification</A></H2>
  <PRE class="code"><SPAN class="reserv-word">class</SPAN> <SPAN class="new-term">output_test_stream</SPAN> {
<SPAN class="reserv-word">pubic</SPAN>:
    <SPAN class="reserv-word">explicit</SPAN>  output_test_stream( <SPAN class="cpp-type">char</SPAN> <SPAN class="reserv-word">const</SPAN>* pattern_file = NULL,
                                  <SPAN class="cpp-type">bool</SPAN> match_or_save = <SPAN class="reserv-word">true</SPAN> );

              ~output_test_stream();

    <SPAN class="cpp-type">bool</SPAN>      is_empty( <SPAN class="cpp-type">bool</SPAN> flush_stream = <SPAN class="reserv-word">true</SPAN> );
    <SPAN class="cpp-type">bool</SPAN>      check_length( std::size_t length, <SPAN class="cpp-type">bool</SPAN> flush_stream = <SPAN class="reserv-word">true</SPAN> );
    <SPAN class="cpp-type">bool</SPAN>      is_equal( <SPAN class="cpp-type">char</SPAN> <SPAN class="reserv-word">const</SPAN>* arg, <SPAN class="cpp-type">bool</SPAN> flush_stream = <SPAN class="reserv-word">true</SPAN> );
    <SPAN class="cpp-type">bool</SPAN>      is_equal( <SPAN class="cpp-type">std::string</SPAN> <SPAN class="reserv-word">const</SPAN>& arg, <SPAN class="cpp-type">bool</SPAN> flush_stream = <SPAN class="reserv-word">true</SPAN> );
    <SPAN class="cpp-type">bool</SPAN>      is_equal( <SPAN class="cpp-type">char</SPAN> <SPAN class="reserv-word">const</SPAN>* arg, <SPAN class="cpp-type">std::size_t</SPAN> n,
                        <SPAN class="cpp-type">bool</SPAN> flush_stream = <SPAN class="reserv-word">true</SPAN> );

    <SPAN class="cpp-type">bool</SPAN>      match_pattern( <SPAN class="cpp-type">bool</SPAN> flush_stream = <SPAN class="reserv-word">true</SPAN> );

    <SPAN class="cpp-type">void</SPAN>      flush();
};
</PRE>
  <P>explicit <SPAN class="new-term"><A name="output_test_stream constructor">output_test_stream</A></SPAN>(
    char const* pattern_file = NULL, bool match_or_save = true );</P>
  <P class="1-line-indented">The class output_test_stream constructor accept pattern
    file name and boolean switch match_or_save that are used by <A href="#match_pattern">match_pattern</A>
    facility. If they are not present you can still use other testing mechanisms.</P>
  <P>void <SPAN class="new-term">flush</SPAN>();</P>
  <P class="1-line-indented">The method output_test_stream::flush() is used to clean
    the content of the output_test_stream instance.</P>
  <P>bool <SPAN class="new-term">is_empty</SPAN>( bool flush_stream = true );</P>
  <P class="1-line-indented">The method output_test_stream::is_empty(...) is used to
    check that the content of the output_test_stream instance is empty. The flush_stream
    argument manage automatic call of the method output_test_stream::flush() after
    check is done.</P>
  <P> bool <SPAN class="new-term">check_length</SPAN>( std::size_t length, bool flush_stream
    = true );</P>
  <P class="1-line-indented">The method output_test_stream::check_length(...) is used
    to check that the length of the content of the output_test_stream instance is equal
    to supplied length value. The flush_stream argument manage automatic call of the
    method output_test_stream::flush() after check is done.</P>
  <P> bool <SPAN class="new-term">is_equal</SPAN>( char const* arg, bool flush_stream
    = true );<BR>
    bool <SPAN class="new-term">is_equal</SPAN>( std::string const& arg, bool flush_stream
    = true );<BR>
    bool <SPAN class="new-term">is_equal</SPAN>( char const* arg, std::size_t n, bool
    flush_stream = true );</P>
  <P class="1-line-indented">The overloaded method output_test_stream::is_equal(...)
    is used to check that the content of the output_test_stream instance is equal to
    supplied character string. The first version compare with null-terminated string.
    The second compare with a reference to std::string object. And finnaly the third
    version compare with probably not null-terminated string defined by pointer to
    the string begin and the string length. The flush_stream argument manage automatic
    call of the method output_test_stream::flush() after check is done.</P>
  <P>bool <SPAN class="new-term"><A name="match_pattern">match_pattern</A></SPAN>(
    bool flush_stream = true );</P>
  <P class="1-line-indented">The method output_test_stream::match_pattern(...) is used
    to match the content of the output_test_stream instance versus the pattern file.
    The pattern file name is specified in the class output_test_stream <A href="#output_test_stream constructor">constructor</A>.
    If second argument of the class output_test_stream <A href="#output_test_stream constructor">constructor</A>
    is false, then every call of the method output_test_stream::match_pattern(...)
    will cause the output_test_stream instance content to be <SPAN style="text-decoration: underline">stored</SPAN>
    at the end of the pattern file. The flush_stream argument manage automatic call
    of the method output_test_stream::flush() after check is done.</P>
  <H2><A name="Tests">Examlpes and Tests</A></H2>
  <P class="indented"> <a href="components_testing.htm#output_test_stream_test">output_test_stream_test</a><BR>
    <a href="components_testing.htm#result_report_test">result_report_test</a><BR>
    <a href="components_testing.htm#test_tools_test">test_tools_test</a><BR>
    <SPAN class="ref-to-top"><A href="#TOP"><IMG src="imgs/uarrow.gif" alt="reference to the top"></A></SPAN>
  <a href="components_testing.htm#errors_handling_test">errors_handling_test</a></P>
  <BR>
  <DIV class="footer">
    <P>&copy <A href='mailto:rogeeff@emailaccount.com'>Gennadiy Rozental</A> 2001-2002
    </P>
    <P>Revised: 12 February, 2003</P>
  </DIV>
  </TD>
  </TR>
  </TABLE>
</DIV>
</BODY>
</HTML>